 3rdparty/heci/COPYING                |   39 
 3rdparty/heci/Kconfig                |    7 
 3rdparty/heci/Makefile               |    5 
 3rdparty/heci/heci.h                 |  141 +++
 3rdparty/heci/heci_data_structures.h |  538 +++++++++++++
 3rdparty/heci/heci_init.c            | 1121 +++++++++++++++++++++++++++
 3rdparty/heci/heci_interface.c       |  525 ++++++++++++
 3rdparty/heci/heci_interface.h       |  177 ++++
 3rdparty/heci/heci_main.c            | 1444 +++++++++++++++++++++++++++++++++++
 3rdparty/heci/interrupt.c            | 1413 ++++++++++++++++++++++++++++++++++
 3rdparty/heci/io_heci.c              | 1138 +++++++++++++++++++++++++++
 3rdparty/heci/kcompat.h              |  165 +++
 3rdparty/heci/version.h              |   53 +
 13 files changed, 6766 insertions(+)
diff -Nurp linux-2.6.37/3rdparty/heci/COPYING linux-2.6.37.3rdparty/3rdparty/heci/COPYING
--- linux-2.6.37/3rdparty/heci/COPYING	1970-01-01 02:00:00.000000000 +0200
+++ linux-2.6.37.3rdparty/3rdparty/heci/COPYING	2008-01-24 14:04:21.000000000 +0200
@@ -0,0 +1,39 @@
+/*
+ * Part of "Intel(R) Manageability Engine Interface" Linux driver 
+ *
+ * Copyright (c) 2007 Intel Corp.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions, and the following disclaimer,
+ *    without modification.
+ * 2. Redistributions in binary form must reproduce at minimum a disclaimer
+ *    substantially similar to the "NO WARRANTY" disclaimer below
+ *    ("Disclaimer") and any redistribution must be conditioned upon
+ *    including a substantially similar Disclaimer requirement for further
+ *    binary redistribution.
+ * 3. Neither the names of the above-listed copyright holders nor the names
+ *    of any contributors may be used to endorse or promote products derived
+ *    from this software without specific prior written permission.
+ *
+ * Alternatively, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") version 2 as published by the Free
+ * Software Foundation.
+ *
+ * NO WARRANTY
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGES.
+ *
+ */
diff -Nurp linux-2.6.37/3rdparty/heci/heci_data_structures.h linux-2.6.37.3rdparty/3rdparty/heci/heci_data_structures.h
--- linux-2.6.37/3rdparty/heci/heci_data_structures.h	1970-01-01 02:00:00.000000000 +0200
+++ linux-2.6.37.3rdparty/3rdparty/heci/heci_data_structures.h	2008-01-24 14:04:22.000000000 +0200
@@ -0,0 +1,538 @@
+/*
+ * Part of Intel(R) Manageability Engine Interface Linux driver
+ *
+ * Copyright (c) 2003 - 2007 Intel Corp.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions, and the following disclaimer,
+ *    without modification.
+ * 2. Redistributions in binary form must reproduce at minimum a disclaimer
+ *    substantially similar to the "NO WARRANTY" disclaimer below
+ *    ("Disclaimer") and any redistribution must be conditioned upon
+ *    including a substantially similar Disclaimer requirement for further
+ *    binary redistribution.
+ * 3. Neither the names of the above-listed copyright holders nor the names
+ *    of any contributors may be used to endorse or promote products derived
+ *    from this software without specific prior written permission.
+ *
+ * Alternatively, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") version 2 as published by the Free
+ * Software Foundation.
+ *
+ * NO WARRANTY
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGES.
+ *
+ */
+
+#ifndef _HECI_DATA_STRUCTURES_H_
+#define _HECI_DATA_STRUCTURES_H_
+
+#include <linux/version.h>
+#include <linux/spinlock.h>
+#include <linux/list.h>
+#include <linux/pci.h>
+#include <linux/timer.h>
+#include <linux/interrupt.h>
+#include <linux/workqueue.h>
+#include <linux/module.h>
+#include <linux/aio.h>
+#include <linux/types.h>
+
+/**
+ * error code definition
+ */
+#define     ESUCCESS                     0
+#define     ESLOTS_OVERFLOW              1
+#define     ECORRUPTED_MESSAGE_HEADER    1000
+#define     ECOMPLETE_MESSAGE            1001
+#define     FC_MESSAGE_RESERVED_LENGTH           5
+
+/**
+ * Number of queue lists used by this driver
+ */
+#define NUMBER_OF_LISTS        7
+
+#define LEGACY_MTU 4160
+#pragma pack(1)
+
+
+/**
+ * HECI HW Section
+ */
+
+/* HECI addresses and defines */
+#define H_CB_WW    0
+#define H_CSR      4
+#define ME_CB_RW   8
+#define ME_CSR_HA  0xC
+
+
+/* register bits - H_CSR */
+
+#define H_CBD             0xFF000000
+#define H_CBWP            0x00FF0000
+#define H_CBRP            0x0000FF00
+#define H_RST             0x00000010
+#define H_RDY             0x00000008
+#define H_IG              0x00000004
+#define H_IS              0x00000002
+#define H_IE              0x00000001
+
+
+/* register bits - ME_CSR_HA */
+#define ME_CBD_HRA        0xFF000000
+#define ME_CBWP_HRA       0x00FF0000
+#define ME_CBRP_HRA       0x0000FF00
+#define ME_RST_HRA        0x00000010
+#define ME_RDY_HRA        0x00000008
+#define ME_IG_HRA         0x00000004
+#define ME_IS_HRA         0x00000002
+#define ME_IE_HRA         0x00000001
+
+/**
+ *  heci driver use additional char device for legacy mode
+ */
+#define  MINORS_COUNT	2
+
+#define  LEGACY_MINOR_NUMBER	0
+#define  HECI_MINOR_NUMBER	1
+#define  MAX_OPEN_HANDLE_COUNT	253
+/**
+ * debug kernel print macro define
+ */
+#define	INFO(format, arg...)	        printk(KERN_INFO     "%s: " format, THIS_MODULE->name, ## arg)
+#define	ERR(format, arg...)	            printk(KERN_ERR      "%s: " format, THIS_MODULE->name, ## arg)
+#define WARN(format, arg...)            printk(KERN_WARNING  "%s: " format, THIS_MODULE->name, ## arg)
+
+
+/* Module Parameters */
+#define	DEF_PARM(type, name, init, perm, desc)	\
+	type name = (init);	\
+	MODULE_PARM_DESC(name, desc);	\
+	module_param(name, type, perm)
+
+extern int debug;
+
+#define DBG(format, arg...) do {if (debug) \
+printk(KERN_ERR "%s: " format , __func__ , ## arg); \
+} while (0)
+
+#ifdef HECI_DEBUG
+#define assert(expr) do {} while (0)
+#else
+#define assert(expr) \
+    if (!(expr)) {                                   \
+    printk("Assertion failed! %s, %s, %s, line=%d\n", \
+    #expr, __FILE__, __func__, __LINE__);          \
+    }
+#endif
+
+/**
+ * time to wait event
+ */
+#define HECI_INTEROP_TIMEOUT    (HZ * 7)
+
+/**
+ * watch dog definition
+ */
+#define HECI_WATCHDOG_DATA_SIZE         16
+#define HECI_START_WD_DATA_SIZE         20
+#define HECI_WD_PARAMS_SIZE             4
+
+#define HECI_NO_MSG_SENT			0
+#define HECI_WD_STATE_INDEPENDENCE_MSG_SENT 	(1 << 0)
+
+
+#define HECI_WD_HOST_CLIENT_ID          1
+#define HECI_LEGACY_HOST_CLIENT_ID      2
+
+#undef FALSE
+#undef TRUE
+#define TRUE  1
+#define FALSE 0
+
+struct guid {
+	__u32 data1;
+	__u16 data2;
+	__u16 data3;
+	__u8 data4[8];
+};
+
+/* File state */
+enum file_state {
+	HECI_FILE_INITIALIZING = 0,
+	HECI_FILE_CONNECTING,
+	HECI_FILE_CONNECTED,
+	HECI_FILE_DISCONNECTING,
+	HECI_FILE_DISCONNECTED
+};
+
+/* HECI states */
+enum heci_states{
+	HECI_INITIALIZING = 0,
+	HECI_ENABLED,
+	HECI_RESETING,
+	HECI_DISABLED,
+	HECI_RECOVERING_FROM_RESET,
+	HECI_POWER_DOWN,
+	HECI_POWER_UP
+};
+
+enum legacy_states {
+	HECI_LEGACY_IDLE,
+	HECI_LEGACY_WRITING,
+	HECI_LEGACY_FLOW_CONTROL,
+	HECI_LEGACY_READING,
+	HECI_LEGACY_READ_COMPLETE
+};
+
+enum heci_file_transaction_states {
+	HECI_IDLE,
+	HECI_WRITING,
+	HECI_WRITE_COMPLETE,
+	HECI_FLOW_CONTROL,
+	HECI_READING,
+	HECI_READ_COMPLETE
+};
+
+/* HECI CB */
+enum heci_cb_major_types {
+	HECI_READ = 0,
+	HECI_WRITE,
+	HECI_IOCTL,
+	HECI_OPEN,
+	HECI_CLOSE
+};
+
+/* HECI user data struct */
+struct heci_message_data {
+	__u32 size;
+	char *data;
+};
+#define SECOND_TO_MILLI                 1000
+#define SECOND_TO_MICRO                 SECOND_TO_MILLI * 1000
+#define SECOND_TO_100NANO               SECOND_TO_MICRO * 10
+
+#define CONNECT_TIMEOUT                 3	/* at least 2 seconds */
+
+#define LEGACY_STALL_TIMER              12	/* seconds */
+#define LEGACY_READ_TIMER               15	/* seconds */
+
+struct heci_cb_private {
+	struct list_head cb_list;
+	enum heci_cb_major_types major_file_operations;
+	void *file_private;
+	struct heci_message_data request_buffer;
+	struct heci_message_data response_buffer;
+	unsigned long information;
+	unsigned long read_time;
+	struct file *file_object;
+};
+
+/* Private file struct */
+struct heci_file_private {
+	struct list_head link;
+	struct file *file;
+	enum file_state state;
+	wait_queue_head_t tx_wait;
+	wait_queue_head_t rx_wait;
+	wait_queue_head_t wait;
+	spinlock_t file_lock;
+	spinlock_t read_io_lock;
+	spinlock_t write_io_lock;
+	int read_pending;
+	int status;
+	/* ID of client connected */
+	__u8 host_client_id;
+	__u8 me_client_id;
+	__u8 flow_control_credentials;
+	__u8 timer_count;
+	enum heci_file_transaction_states reading_state;
+	enum heci_file_transaction_states writing_state;
+	int sm_state;
+	struct heci_cb_private *read_cb;
+};
+
+struct io_heci_list {
+	struct heci_cb_private heci_cb;
+	int status;
+	struct iamt_heci_device *device_extension;
+};
+
+struct heci_driver_version {
+	__u8 major;
+	__u8 minor;
+	__u8 hotfix;
+	__u16 build;
+};
+
+
+struct heci_client {
+	__u32 max_message_length;
+	__u8 protocol_version;
+};
+/*
+ *  HECI BUS Interface Section
+ */
+struct heci_message_header {
+	__u32 me_address:8;
+	__u32 host_address:8;
+	__u32 length:9;
+	__u32 reserved:6;
+	__u32 message_complete:1;
+};
+
+
+struct hbm_command {
+	__u8 command:7;
+	__u8 is_response:1;
+};
+
+
+struct heci_bus_message {
+	struct hbm_command command;
+	__u8 command_specific_data[];
+};
+
+struct hbm_version {
+	__u8 minor_version;
+	__u8 major_version;
+};
+
+struct hbm_host_version_request {
+	struct hbm_command command;
+	__u8 reserved;
+	struct hbm_version host_version;
+};
+
+struct hbm_host_version_response {
+	struct hbm_command command;
+	int host_version_supported;
+	struct hbm_version me_max_version;
+};
+
+struct hbm_host_stop_request {
+	struct hbm_command command;
+	__u8 reason;
+	__u8 reserved[2];
+};
+
+struct hbm_host_stop_response {
+	struct hbm_command command;
+	__u8 reserved[3];
+};
+
+struct hbm_me_stop_request {
+	struct hbm_command command;
+	__u8 reason;
+	__u8 reserved[2];
+};
+
+struct hbm_host_enumeration_request {
+	struct hbm_command command;
+	__u8 reserved[3];
+};
+
+struct hbm_host_enumeration_response {
+	struct hbm_command command;
+	__u8 reserved[3];
+	__u8 valid_addresses[32];
+};
+
+struct heci_client_properties {
+	struct guid protocol_name;
+	__u8 protocol_version;
+	__u8 max_number_of_connections;
+	__u8 fixed_address;
+	__u8 single_receive_buffer;
+	__u32 max_message_length;
+};
+
+struct hbm_host_client_properties_request {
+	struct hbm_command command;
+	__u8 address;
+	__u8 reserved[2];
+};
+
+
+struct hbm_host_client_properties_response {
+	struct hbm_command command;
+	__u8 address;
+	__u8 status;
+	__u8 reserved[1];
+	struct heci_client_properties client_properties;
+};
+
+struct hbm_client_connect_request {
+	struct hbm_command command;
+	__u8 me_address;
+	__u8 host_address;
+	__u8 reserved;
+};
+
+struct hbm_client_connect_response {
+	struct hbm_command command;
+	__u8 me_address;
+	__u8 host_address;
+	__u8 status;
+};
+
+struct hbm_client_disconnect_request {
+	struct hbm_command command;
+	__u8 me_address;
+	__u8 host_address;
+	__u8 reserved[1];
+};
+
+struct hbm_flow_control {
+	struct hbm_command command;
+	__u8 me_address;
+	__u8 host_address;
+	__u8 reserved[FC_MESSAGE_RESERVED_LENGTH];
+};
+
+struct heci_me_client {
+	struct heci_client_properties properteis;
+	__u8 client_id;
+	__u8 flow_control_credentials;
+};
+
+/* private device struct */
+struct iamt_heci_device {
+	struct pci_dev *pdev;	/* pointer to pci device struct */
+	/*
+	 * lists of queues
+	 */
+	struct io_heci_list *io_list_array[NUMBER_OF_LISTS];	/* array of pointers to  aio lists */
+	struct io_heci_list read_list;	/* driver  read queue */
+	struct io_heci_list write_list;	/* driver write queue */
+	struct io_heci_list write_waiting_list;	/* driver write waiting queue */
+	struct io_heci_list control_write_list;	/* driver managed write IOCTL list */
+	struct io_heci_list control_read_list;	/* driver managed read IOCTL list */
+	struct io_heci_list pthi_cmd_list;	/* driver managed PTHI list for cmd waiting */
+	struct io_heci_list pthi_read_complete_list;	/* driver managed PTHI list for  read completed pthi command data */
+	/*
+	 * list of files
+	 */
+	struct list_head file_list;
+	/*
+	 * memory of device
+	 */
+	unsigned int mem_base;
+	unsigned int mem_length;
+	char *mem_addr;
+	/*
+	 * lock for the device
+	 */
+	spinlock_t device_lock;
+	spinlock_t extra_lock;
+	/*
+	 * intterupts
+	 */
+	int irq;
+	struct work_struct work;
+	int received_message;
+
+	struct timer_list timer;
+	struct timer_list wd_timer;
+	/*
+	 * hw states of host and fw(ME)
+	 */
+	__u32 host_hw_state;
+	__u32 me_hw_state;
+	/*
+	 * waiting queue for receive message from FW
+	 */
+	wait_queue_head_t wait_received_message;
+	wait_queue_head_t wait_stop_wd;
+	/*
+	 * heci device  states
+	 */
+	enum heci_states heci_state;
+	int stop;
+     /**
+      * virtual void GetParam(const char* UserParam);
+      * read write messages to/from heci fw
+      */
+	__u32 extra_write_index;
+	__u32 read_message_buffer[128];	/* used for control messages */
+	__u32 write_message_buffer[128];	/* used for control messages */
+	__u32 extra_message_buffer[8];	/* for control responses    */
+	__u32 read_message_header;
+
+	struct hbm_version version;
+
+	int host_buffer_is_empty;
+	struct heci_file_private wd_file_extension;
+	struct heci_me_client *me_clients;	/* Note: memory has to be allocated */
+	__u8 heci_me_clients[32];	/* list of existing clients */
+	__u8 num_heci_me_clients;
+	__u8 heci_host_clients[32];	/* list of existing clients */
+	__u8 current_host_client_id;
+
+	int wd_pending;
+	int wd_stoped;
+	__u16 wd_timeout;	/* seconds ((wd_data[1] << 8) + wd_data[0]) */
+	unsigned char wd_data[HECI_START_WD_DATA_SIZE];
+
+
+	__u16 wd_due_counter;
+	int asf_mode;
+	int	wd_bypass;	/* if true,don't refresh watchdog ME client */
+
+	/* maybe this is not required */
+	struct file *legacy_file_object;
+	struct heci_file_private legacy_file_extension;
+	int legacy_ioctl;
+	int legacy_canceled;
+	__u32 legacy_timer;
+	__u32 legacy_stall_timer;
+	unsigned char legacy_message_buffer[LEGACY_MTU];
+	__u32 legacy_message_buffer_size;
+	__u32 legacy_message_buffer_index;
+	int legacy_flow_control_pending;
+	enum legacy_states legacy_state;
+
+	struct heci_cb_private *legacy_current_cb;
+	__u8 write_hang;
+	int need_reset;
+	long open_handle_count;
+
+};
+
+/**
+ * read_heci_register - Read a byte from the heci device
+ * @device: the device structure
+ * @offset: offset from which to read the data
+ *
+ * Return:
+ * the byte read.
+ */
+__u32 read_heci_register(struct iamt_heci_device * device,
+			    unsigned long offset);
+
+/**
+ * write_heci_register - Write  4 bytes to the heci device
+ * @device: the device structure
+ * @offset: offset from which to write the data
+ *
+ * @value: the byte to write
+ */
+void write_heci_register(struct iamt_heci_device * device, unsigned long offset,
+			 __u32 value);
+
+#endif				/* _HECI_DATA_STRUCTURES_H_ */
diff -Nurp linux-2.6.37/3rdparty/heci/heci.h linux-2.6.37.3rdparty/3rdparty/heci/heci.h
--- linux-2.6.37/3rdparty/heci/heci.h	1970-01-01 02:00:00.000000000 +0200
+++ linux-2.6.37.3rdparty/3rdparty/heci/heci.h	2008-01-24 14:04:21.000000000 +0200
@@ -0,0 +1,141 @@
+/*
+ * Part of Intel(R) Manageability Engine Interface Linux driver
+ *
+ * Copyright (c) 2003 - 2007 Intel Corp.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions, and the following disclaimer,
+ *    without modification.
+ * 2. Redistributions in binary form must reproduce at minimum a disclaimer
+ *    substantially similar to the "NO WARRANTY" disclaimer below
+ *    ("Disclaimer") and any redistribution must be conditioned upon
+ *    including a substantially similar Disclaimer requirement for further
+ *    binary redistribution.
+ * 3. Neither the names of the above-listed copyright holders nor the names
+ *    of any contributors may be used to endorse or promote products derived
+ *    from this software without specific prior written permission.
+ *
+ * Alternatively, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") version 2 as published by the Free
+ * Software Foundation.
+ *
+ * NO WARRANTY
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGES.
+ *
+ */
+
+#ifndef _HECI_H_
+#define _HECI_H_
+
+#include <linux/version.h>
+#include <linux/spinlock.h>
+#include <linux/list.h>
+#include <linux/pci.h>
+#include <linux/timer.h>
+#include <linux/interrupt.h>
+#include <linux/workqueue.h>
+#include <linux/module.h>
+#include <linux/aio.h>
+#include <linux/types.h>
+#include "heci_data_structures.h"
+
+
+extern const struct guid heci_pthi_guid;
+extern const struct guid heci_wd_guid;
+extern const __u8 start_wd_params[];
+extern const __u8 stop_wd_params[];
+extern const __u8 heci_wd_state_independence_msg[2][4];
+
+/**
+ * memory IO BAR definition
+ */
+#define     BAR_0                        0
+#define     BAR_1                        1
+#define     BAR_5                        5
+/**
+ * Number of queue lists used by this driver
+ */
+#define    PCI_HECI_DEVICE_ID1   0x2974
+#define    PCI_HECI_DEVICE_ID2   0x2984
+#define    PCI_HECI_DEVICE_ID3   0x2994
+#define    PCI_HECI_DEVICE_ID4   0x29A4
+#define    PCI_HECI_DEVICE_ID5   0x29B4
+#define    PCI_HECI_DEVICE_ID6   0x29C4
+#define    PCI_HECI_DEVICE_ID7   0x29E4
+#define    PCI_HECI_DEVICE_ID8   0x29F4
+
+/**
+ * heci init function prototypes
+ */
+struct iamt_heci_device *init_heci_device(struct pci_dev *pdev);
+void heci_reset(struct iamt_heci_device * device_object, int interrupts);
+int heci_hw_init(struct iamt_heci_device * device_object);
+int heci_initialize_clients(void *data);
+struct heci_file_private *alloc_priv(struct file *file);
+int heci_disconnect_host_client(struct iamt_heci_device * device_object,
+				struct heci_file_private * file_extension);
+void heci_initialize_list(struct io_heci_list *list,
+			  struct iamt_heci_device * device_object);
+void heci_flush_list(struct io_heci_list *list,
+		     struct heci_file_private * file_extension);
+void heci_flush_queues(struct iamt_heci_device * device_object,
+		       struct heci_file_private * file_extension);
+
+void heci_remove_client_from_file_list(struct iamt_heci_device * device_object,
+				       __u8 host_client_id);
+
+/**
+ *  interrupt function prototype
+ */
+irqreturn_t heci_isr_interrupt(int irq, void *dev_id);
+void heci_wd_timer(unsigned long data);
+void heci_bh_handler(struct work_struct *work);
+/**
+ *  input output function prototype
+ */
+int heci_ioctl_get_version(struct iamt_heci_device * device, int if_num,
+			   struct heci_message_data *u_msg,
+			   struct heci_message_data k_msg,
+			   struct heci_file_private * file_extension);
+int heci_ioctl_connect_client(struct iamt_heci_device * device, int if_num,
+			      struct heci_message_data *u_msg,
+			      struct heci_message_data k_msg,
+			      struct file *file);
+int heci_ioctl_wd(struct iamt_heci_device * device, int if_num,
+		  struct heci_message_data k_msg,
+		  struct heci_file_private * file_extension);
+int heci_ioctl_bypass_wd(struct iamt_heci_device * device, int if_num,
+		  struct heci_message_data k_msg,
+		  struct heci_file_private * file_extension);
+int legacy_ioctl_send_message(struct iamt_heci_device * device, int if_num,
+			      struct heci_message_data k_msg,
+			      struct file *file);
+int legacy_ioctl_receive_message(struct iamt_heci_device * device, int if_num,
+				 struct heci_message_data *u_msg,
+				 struct heci_message_data k_msg,
+				 struct file *file);
+int heci_start_read(struct iamt_heci_device * device, int if_num,
+		    struct heci_file_private * file_extension);
+int pthi_write(struct iamt_heci_device * device,
+	       struct heci_cb_private *kernel_priv_cb);
+int pthi_read(struct iamt_heci_device * device, int if_num, struct file *file,
+	      char *ubuf, size_t length, loff_t* offset);
+struct heci_cb_private* find_pthi_read_list_entry(struct iamt_heci_device* device,
+					struct file* file, struct heci_file_private* file_extension);
+void run_next_legacy_cmd(struct iamt_heci_device * device);
+
+#endif				/* _HECI_H_ */
diff -Nurp linux-2.6.37/3rdparty/heci/heci_init.c linux-2.6.37.3rdparty/3rdparty/heci/heci_init.c
--- linux-2.6.37/3rdparty/heci/heci_init.c	1970-01-01 02:00:00.000000000 +0200
+++ linux-2.6.37.3rdparty/3rdparty/heci/heci_init.c	2008-01-24 14:04:22.000000000 +0200
@@ -0,0 +1,1121 @@
+/*
+ * Part of Intel(R) Manageability Engine Interface Linux driver
+ *
+ * Copyright (c) 2007 Intel Corp.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions, and the following disclaimer,
+ *    without modification.
+ * 2. Redistributions in binary form must reproduce at minimum a disclaimer
+ *    substantially similar to the "NO WARRANTY" disclaimer below
+ *    ("Disclaimer") and any redistribution must be conditioned upon
+ *    including a substantially similar Disclaimer requirement for further
+ *    binary redistribution.
+ * 3. Neither the names of the above-listed copyright holders nor the names
+ *    of any contributors may be used to endorse or promote products derived
+ *    from this software without specific prior written permission.
+ *
+ * Alternatively, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") version 2 as published by the Free
+ * Software Foundation.
+ *
+ * NO WARRANTY
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGES.
+ *
+ */
+
+#include <linux/module.h>
+#include <linux/pci.h>
+#include <linux/reboot.h>
+#include <asm/uaccess.h>
+#include <linux/poll.h>
+#include <linux/init.h>
+#include <linux/kdev_t.h>
+#include <linux/moduleparam.h>
+#include <linux/wait.h>
+#include <linux/delay.h>
+
+#include "kcompat.h"
+#include "heci_data_structures.h"
+#include "heci_interface.h"
+#include "heci.h"
+
+
+const __u8 watch_dog_data[] =
+    { 1, 1, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14 };
+const __u8 start_wd_params[] = { 0x02, 0x12, 0x13, 0x10 };
+const __u8 stop_wd_params[] = { 0x02, 0x02, 0x14, 0x10 };
+const __u8 heci_wd_state_independence_msg[2][4] = {
+	{0x05, 0x02, 0x51, 0x10}, 
+	{0x05, 0x02, 0x52, 0x10} };
+const struct guid heci_asf_guid =
+    { 0x75B30CD6, 0xA29E, 0x4AF7, {0xA7, 0x12, 0xE6, 0x17, 0x43, 0x93,
+				   0xC8, 0xA6} };
+const struct guid heci_wd_guid =
+    { 0x05B79A6F, 0x4628, 0x4D7F, {0x89, 0x9D, 0xA9, 0x15, 0x14, 0xCB,
+				   0x32, 0xAB} };
+const struct guid heci_pthi_guid =
+    { 0x12f80028, 0xb4b7, 0x4b2d, {0xac, 0xa8, 0x46, 0xe0, 0xff, 0x65,
+				   0x81, 0x4c} };
+
+
+/**
+ *  heci init function prototypes
+ */
+int host_start_message(struct iamt_heci_device * device_object);
+int host_enum_clients_message(struct iamt_heci_device * device_object);
+int allocate_me_clents_storage(struct iamt_heci_device * device_object);
+void heci_disable(struct iamt_heci_device * device_object);
+void host_init_wd(struct iamt_heci_device * device_object);
+void host_init_legacy(struct iamt_heci_device * device_object);
+
+
+/**
+ * heci_initialize_list - Sets up a  queue  list.
+ *
+ * @list - An instance of our list structure
+ * @device_object -Device object for our driver
+ *
+ * @return :
+ * none;
+ */
+void heci_initialize_list(struct io_heci_list *list,
+			  struct iamt_heci_device * device_object)
+{
+	/* initialize our queue list */
+	INIT_LIST_HEAD(&list->heci_cb.cb_list);
+	list->status = ESUCCESS;
+	list->device_extension = device_object;
+	return;
+}
+
+/**
+ * heci_flush_queues - flush our queues list belong to file_extension.
+ *
+ * @device_object -Device object for our driver
+ *
+ * @return :
+ * none;
+ */
+void heci_flush_queues(struct iamt_heci_device * device_object,
+		       struct heci_file_private * file_extension)
+{
+	int i;
+	if (!device_object || !file_extension)
+		return;
+	/* flush our queue list belong to file_extension */
+	for (i = 0; i < NUMBER_OF_LISTS; i++) {
+		DBG("remove list etnry belong to file_extension\n");
+		heci_flush_list(device_object->io_list_array[i],
+				file_extension);
+	}
+
+}
+
+
+/**
+ * heci_flush_list - remove list etnry belong to file_extension.
+ *
+ * @list - An instance of our list structure
+ * @file_extension -extension of the file object
+
+ * @return :
+ * none;
+ */
+void heci_flush_list(struct io_heci_list *list,
+		struct heci_file_private * file_extension)
+{
+	struct heci_file_private *file_extension_temp = NULL;
+	struct heci_cb_private *kernel_priv_cb_pos = NULL, *kernel_priv_cb_next = NULL;
+
+	if (!list || !file_extension)
+		return;
+	if (list->status == ESUCCESS
+	    && !list_empty(&list->heci_cb.cb_list)) {
+        list_for_each_entry_safe(kernel_priv_cb_pos, kernel_priv_cb_next, &list->heci_cb.cb_list, cb_list){
+
+            if (kernel_priv_cb_pos) {
+				file_extension_temp =
+				    (struct heci_file_private *)
+				    kernel_priv_cb_pos->file_private;
+			}
+			if (file_extension_temp) {
+				if ((file_extension->host_client_id == file_extension_temp-> host_client_id)
+				    && (file_extension->me_client_id == file_extension_temp-> me_client_id))
+					list_del(&kernel_priv_cb_pos->cb_list);
+			}
+
+		}
+	}
+	return;
+}
+
+/**
+ * init_heci_device - allocates and initializes the heci device structure
+ * @pdev: The pci device structure
+ *
+ * @return :
+ * The heci_device_device pointer on success, NULL on failure.
+ */
+struct iamt_heci_device *init_heci_device(struct pci_dev * pdev)
+{
+	int i;
+	struct iamt_heci_device *device;
+	device = kmalloc(sizeof(struct iamt_heci_device), GFP_KERNEL);
+	if (!device) {
+		return NULL;
+	}
+
+	/* setup our list array */
+	device->io_list_array[0] = &device->read_list;
+	device->io_list_array[1] = &device->write_list;
+	device->io_list_array[2] = &device->write_waiting_list;
+	device->io_list_array[3] = &device->control_write_list;
+	device->io_list_array[4] = &device->control_read_list;
+	device->io_list_array[5] = &device->pthi_cmd_list;
+	device->io_list_array[6] = &device->pthi_read_complete_list;
+	INIT_LIST_HEAD(&device->file_list);
+	INIT_LIST_HEAD(&device->wd_file_extension.link);
+	INIT_LIST_HEAD(&device->legacy_file_extension.link);
+	spin_lock_init(&device->device_lock);
+	init_waitqueue_head(&device->wait_received_message);
+	init_waitqueue_head(&device->wait_stop_wd);
+	device->open_handle_count = 0;
+	device->num_heci_me_clients = 0;
+	device->mem_base = 0;
+	device->mem_length = 0;
+	device->extra_write_index = 0;
+	device->read_message_header = 0;
+	device->mem_addr = NULL;
+	device->asf_mode = FALSE;
+	device->need_reset = FALSE;
+	device->received_message = FALSE;
+	device->heci_state = HECI_INITIALIZING;
+
+	device->num_heci_me_clients = 0;
+	device->legacy_current_cb = NULL;
+	device->legacy_file_object = NULL;
+	device->legacy_canceled = FALSE;
+	device->legacy_flow_control_pending = FALSE;
+	device->legacy_state = HECI_LEGACY_IDLE;
+	device->legacy_message_buffer_index = 0;
+	device->wd_pending = FALSE;
+	device->wd_stoped = FALSE;
+	device->wd_bypass = FALSE;
+
+	device->me_clients = NULL;
+	/* init work for schedule work */
+	INIT_WORK(&device->work, NULL);
+	for (i = 0; i < NUMBER_OF_LISTS; i++)
+		heci_initialize_list(device->io_list_array[i], device);
+	device->pdev = pdev;
+	return device;
+}
+
+/**
+ * heci_hw_init  - init host and fw to start work.
+ *
+ * @device_object -Device object for our driver
+ *
+ *@return:
+ * 0 on success.
+ * negative on failure
+ */
+int heci_hw_init(struct iamt_heci_device * device_object)
+{
+	int err = 0;
+	device_object->host_hw_state =
+	    read_heci_register(device_object, H_CSR);
+	device_object->me_hw_state =
+	    read_heci_register(device_object, ME_CSR_HA);
+	DBG("host_hw_state = 0x%08x, mestate = 0x%08x.\n",
+	    device_object->host_hw_state, device_object->me_hw_state);
+
+	if ((device_object->host_hw_state & H_IS) == H_IS) {
+		/* acknowledge interrupt and stop interupts */
+		write_heci_register(device_object, H_CSR,
+				    device_object->host_hw_state);
+	}
+	device_object->received_message = FALSE;
+	DBG("reset in start the heci device.\n");
+
+	heci_reset(device_object, TRUE);
+
+	DBG("host_hw_state = 0x%08x, me_hw_state = 0x%08x.\n",
+	    device_object->host_hw_state, device_object->me_hw_state);
+
+	/* wait for ME to turn on ME_RDY */
+	if (!device_object->received_message) {
+		err =
+		    wait_event_interruptible_timeout(device_object->
+						     wait_received_message,
+						     (device_object->
+						      received_message),
+						     HECI_INTEROP_TIMEOUT);
+	}
+
+	if (!err && !device_object->received_message) {
+		device_object->heci_state = HECI_DISABLED;
+		DBG("wait_event_interruptible_timeout failed on wait for ME to turn on ME_RDY.\n");
+		return -ENODEV;
+	} else {
+		if (!(((device_object->host_hw_state & H_RDY) == H_RDY)
+		      && ((device_object->me_hw_state & ME_RDY_HRA) ==
+			  ME_RDY_HRA))) {
+			device_object->heci_state = HECI_DISABLED;
+			DBG("host_hw_state = 0x%08x, me_hw_state = 0x%08x.\n",
+					device_object->host_hw_state,
+					device_object->me_hw_state);
+
+			if (!(device_object->host_hw_state & H_RDY) != H_RDY)
+				DBG("host turn off H_RDY.\n");
+			if (!(device_object->me_hw_state & ME_RDY_HRA) != ME_RDY_HRA)
+				DBG("ME turn off ME_RDY.\n");
+			ERR("link layer initialization failed.\n");
+			return -ENODEV;
+		}
+	}
+	device_object->received_message = FALSE;
+	DBG("host_hw_state = 0x%08x, me_hw_state = 0x%08x.\n",
+	    device_object->host_hw_state, device_object->me_hw_state);
+	DBG("ME turn on ME_RDY and host turn on H_RDY.\n");
+	INFO("link layer has been established.\n");
+	return ESUCCESS;
+}
+
+/**
+ * heci_reset  - reset host and fw.
+ *
+ * @device_object -Device object for our driver
+ * @interrupts - if interrupt should be enable after reset.
+ *
+ * @return:
+ * none;
+ */
+void heci_reset(struct iamt_heci_device * device_object, int interrupts)
+{
+       struct heci_file_private *file_extension_pos = NULL;
+	struct heci_file_private *file_extension_next = NULL;
+	struct heci_cb_private *kernel_priv_cb_pos = NULL, *kernel_priv_cb_next = NULL;
+	int unexpected = 0;
+
+	if (device_object->heci_state == HECI_RECOVERING_FROM_RESET) {
+		device_object->need_reset = TRUE;
+		return;
+	}
+
+	if (device_object->heci_state != HECI_INITIALIZING &&
+	    device_object->heci_state != HECI_DISABLED && 
+		device_object->heci_state != HECI_POWER_DOWN && 
+		device_object->heci_state != HECI_POWER_UP)
+		unexpected = 1; 
+		 
+	device_object->host_hw_state =
+	    read_heci_register(device_object, H_CSR);
+
+	DBG("before reset host_hw_state = 0x%08x.\n",
+	    device_object->host_hw_state);
+
+	device_object->host_hw_state |= (H_RST | H_IG);
+
+	if (interrupts)
+		device_object->host_hw_state |= (H_IE);
+	else
+		device_object->host_hw_state &= ~(H_IE);
+
+	write_heci_register(device_object, H_CSR,
+			    device_object->host_hw_state);
+
+	device_object->host_hw_state =
+	    read_heci_register(device_object, H_CSR);
+	BUG_ON((device_object->host_hw_state & H_RST) != H_RST);
+	BUG_ON((device_object->host_hw_state & H_RDY) != 0);
+
+	device_object->host_hw_state &= ~H_RST;
+	device_object->host_hw_state |= H_IG;
+
+	write_heci_register(device_object, H_CSR,
+			    device_object->host_hw_state);
+
+	DBG("currently saved host_hw_state = 0x%08x.\n",
+	    device_object->host_hw_state);
+
+	device_object->need_reset = FALSE;
+
+	if (device_object->heci_state != HECI_INITIALIZING) {
+		if (device_object->heci_state != HECI_DISABLED && 
+			device_object->heci_state != HECI_POWER_DOWN) {
+			device_object->heci_state = HECI_RESETING;
+		}
+		list_for_each_entry_safe(file_extension_pos, file_extension_next, &device_object->file_list, link) {
+			file_extension_pos->state =HECI_FILE_DISCONNECTED;
+			file_extension_pos->flow_control_credentials =0;
+			file_extension_pos->read_cb = NULL;
+			file_extension_pos->timer_count = 0;
+		}
+		/* remove entry if already in list */
+		DBG("list del legacy and wd file list.\n");
+		heci_remove_client_from_file_list(device_object,
+						  device_object->
+						  wd_file_extension.
+						  host_client_id);
+
+		heci_remove_client_from_file_list(device_object,
+						  device_object->
+						  legacy_file_extension.
+						  host_client_id);
+		/* reset legacy parameters. */
+		device_object->legacy_current_cb = NULL;
+		device_object->legacy_message_buffer_size = 0;
+		device_object->legacy_message_buffer_index = 0;
+		device_object->legacy_canceled = FALSE;
+		device_object->legacy_file_extension.file = NULL;
+		device_object->legacy_ioctl = FALSE;
+		device_object->legacy_state = HECI_LEGACY_IDLE;
+		device_object->legacy_timer = 0;
+		device_object->wd_due_counter = 0;
+		device_object->extra_write_index = 0;
+		device_object->wd_pending = FALSE;
+	}
+
+	device_object->num_heci_me_clients = 0;
+	device_object->read_message_header = 0;
+	device_object->stop = FALSE;
+	device_object->wd_pending = 0;
+
+	/* update the state of the registers after reset */
+	device_object->host_hw_state =
+	    read_heci_register(device_object, H_CSR);
+	device_object->me_hw_state =
+	    read_heci_register(device_object, ME_CSR_HA);
+
+	DBG("after reset host_hw_state = 0x%08x, me_hw_state = 0x%08x.\n",
+	    device_object->host_hw_state, device_object->me_hw_state);
+
+	if (unexpected)
+		ERR("unexpected heci reset.\n");
+	//Wake up all readings so they can be interrupted
+	list_for_each_entry_safe(file_extension_pos,file_extension_next, &device_object->file_list,link) {
+			if (&file_extension_pos->rx_wait &&
+				waitqueue_active (&file_extension_pos->rx_wait)) {
+					INFO("Waking up client!\n");
+					wake_up_interruptible(&file_extension_pos->rx_wait);
+			}
+		}
+	// remove all waiting requests
+	if (device_object->write_list.status == ESUCCESS && !list_empty(&device_object->write_list.heci_cb.cb_list)) {
+		list_for_each_entry_safe(kernel_priv_cb_pos, kernel_priv_cb_next, &device_object->write_list.heci_cb.cb_list, cb_list){
+				if (kernel_priv_cb_pos) {
+					list_del(&kernel_priv_cb_pos->cb_list);
+					kfree(kernel_priv_cb_pos->request_buffer.data);
+					kernel_priv_cb_pos->request_buffer.data = NULL;
+					kfree(kernel_priv_cb_pos->response_buffer.data);
+					kernel_priv_cb_pos->response_buffer.data = NULL;
+					kfree(kernel_priv_cb_pos);
+					kernel_priv_cb_pos = NULL;
+				}
+		}
+	}
+}
+
+/**
+ * heci_disable  - reseting in disable routine.
+ *
+ * @device_object -Device object for our driver
+ *
+ * @return:
+ * none;
+ */
+void heci_disable(struct iamt_heci_device * device_object)
+{
+	if (device_object->heci_state != HECI_INITIALIZING)
+		ERR("driver stop request heci state is disable.\n");
+	device_object->heci_state = HECI_DISABLED;
+}
+
+/**
+ * heci_initialize_clients  -  routine.
+ *
+ * @device_object -Device object for our driver
+ *
+ * @return:
+ * none;
+ */
+int heci_initialize_clients(void *data)
+{
+
+	int status;
+	struct iamt_heci_device *device_object = (struct iamt_heci_device *) data;
+	DBG("link is established start sending messages.\n");
+	/* link is established start sending messages. */
+	status = host_start_message(device_object);
+	if (status) {
+		DBG("start sending messages failed.\n");
+		return -ENODEV;
+	}
+	/* enumerate clients */
+
+	status = host_enum_clients_message(device_object);
+	if (status) {
+		DBG("enum clients failed.\n");
+		return -ENODEV;
+	}
+	/* allocate storage for ME clients representation */
+	status = allocate_me_clents_storage(device_object);
+	if (status) {
+		DBG("allocate clients failed.\n");
+		return -ENODEV;
+	}
+	/*heci initialization wd */
+	host_init_wd(device_object);
+	/*heci initialization legacy client */
+	host_init_legacy(device_object);
+	if (device_object->need_reset) {
+		device_object->need_reset = FALSE;
+		device_object->heci_state = HECI_DISABLED;
+		return -ENODEV;
+	}
+
+	memset(device_object->heci_host_clients, 0,
+	       sizeof(device_object->heci_host_clients));
+	device_object->open_handle_count = 0;
+	device_object->heci_host_clients[0] |= 7;
+	device_object->current_host_client_id = 3;
+	device_object->heci_state = HECI_ENABLED;
+	DBG("initialization heci clients successful.\n");
+	return ESUCCESS;
+}
+
+/**
+ * host_start_message - heci host send start message.
+ *
+ * @device_object - Device object for our driver
+ *
+ * @return :
+ *  0 on success,
+ *  negative on failure.
+ */
+int host_start_message(struct iamt_heci_device * device_object)
+{
+	long timeout = 60;	/* 60 second */
+
+	struct heci_message_header *heci_header;
+	struct hbm_host_version_request *host_start_req;
+	struct hbm_host_stop_request *host_stop_req;
+	int err = 0;
+	/* host start message */
+	msleep(100);
+	heci_header =
+	    (struct heci_message_header *) & device_object->
+	    write_message_buffer[0];
+	heci_header->host_address = 0;
+	heci_header->me_address = 0;
+	heci_header->length = sizeof(struct hbm_host_version_request);
+	heci_header->message_complete = 1;
+	heci_header->reserved = 0;
+
+	host_start_req =
+	    (struct hbm_host_version_request *) & device_object->
+	    write_message_buffer[1];
+	memset(host_start_req, 0, sizeof(host_start_req));
+	host_start_req->command.command = HOST_START_REQ_CMD;
+	host_start_req->reserved = 0;
+	host_start_req->host_version.major_version = HBM_MAJOR_VERSION;
+	host_start_req->host_version.minor_version = HBM_MINOR_VERSION;
+	device_object->received_message = FALSE;
+	if (!heci_write_message(device_object, heci_header,
+				       (unsigned char *) (host_start_req),
+				       heci_header->length)) {
+		device_object->heci_state = HECI_DISABLED;
+		DBG("send version to fw fail.\n");
+		return -ENODEV;
+	}
+	DBG("call wait_event_interruptible_timeout  for response message. \n");
+	/* wait for response */
+	err =
+	    wait_event_interruptible_timeout(device_object->
+					     wait_received_message,
+					     (device_object->
+					      received_message),
+					     timeout * HZ);
+	if (!err && !device_object->received_message) {
+		device_object->heci_state = HECI_DISABLED;
+		DBG("wait_event_interruptible_timeout failed on host start response message. \n");
+		return -ENODEV;
+	}
+	device_object->received_message = FALSE;
+	DBG("wait_event_interruptible_timeout successful on host start response message. \n");
+	if ((device_object->version.major_version != HBM_MAJOR_VERSION) ||
+	    (device_object->version.minor_version != HBM_MINOR_VERSION)) {
+		/* send stop message */
+		heci_header->host_address = 0;
+		heci_header->me_address = 0;
+		heci_header->length = sizeof(struct hbm_host_stop_request);
+		heci_header->message_complete = 1;
+		heci_header->reserved = 0;
+
+		host_stop_req =
+		    (struct hbm_host_stop_request *) & device_object->
+		    write_message_buffer[1];
+
+		memset(host_stop_req, 0, sizeof(host_stop_req));
+		host_stop_req->command.command = HOST_STOP_REQ_CMD;
+		host_stop_req->reason = DRIVER_STOP_REQUEST;
+		memset(host_stop_req->reserved, 0,
+		       sizeof(host_stop_req->reserved));
+		heci_write_message(device_object, heci_header,
+				   (unsigned char *) (host_stop_req),
+				   heci_header->length);
+		DBG("version  mismatch.\n");
+		return -ENODEV;
+	}
+
+	return ESUCCESS;
+}
+
+/**
+ * host_enum_clients_message - host send enumeration client request message.
+ *
+ * @device_object - Device object for our driver
+ *
+ * @return :
+ *  0 on success,
+ *  negative on failure.
+ */
+int host_enum_clients_message(struct iamt_heci_device * device_object)
+{
+	long timeout = 5;	/*5 second */
+
+	struct heci_message_header *heci_header;
+	struct hbm_host_enumeration_request *host_enum_req;
+	int err = 0;
+	__u8 i, j;
+	heci_header =
+	    (struct heci_message_header *) & device_object->
+	    write_message_buffer[0];
+	/* enumerate clients */
+	heci_header->host_address = 0;
+	heci_header->me_address = 0;
+	heci_header->length = sizeof(struct hbm_host_enumeration_request);
+	heci_header->message_complete = 1;
+	heci_header->reserved = 0;
+
+	host_enum_req =
+	    (struct hbm_host_enumeration_request *) & device_object->
+	    write_message_buffer[1];
+	memset(host_enum_req, 0, sizeof(host_enum_req));
+	host_enum_req->command.command = HOST_ENUM_REQ_CMD;
+	memset(host_enum_req->reserved, 0,
+	       sizeof(host_enum_req->reserved));
+	if (!heci_write_message(device_object, heci_header,
+			       (unsigned char *) (host_enum_req),
+			       heci_header->length)) {
+		device_object->heci_state = HECI_DISABLED;
+		DBG("send enumeration request fail.\n");
+		return -ENODEV;
+	}
+	/* wait for response */
+	device_object->received_message = FALSE;
+	err =
+	    wait_event_interruptible_timeout(device_object->
+					     wait_received_message,
+					     (device_object->
+					      received_message),
+					     timeout * HZ);
+	if (!err && !device_object->received_message) {
+
+		device_object->heci_state = HECI_DISABLED;
+
+		DBG("wait_event_interruptible_timeout failed on enumeration cients response message. \n");
+		return -ENODEV;
+	}
+	device_object->received_message = FALSE;
+	/* count how many ME clients we have */
+	for (i = 0; i < sizeof(device_object->heci_me_clients); i++)
+		for (j = 0; j < 8; j++)
+			if ((device_object->heci_me_clients[i] & (1 << j)) != 0)
+				device_object->num_heci_me_clients++;
+	return ESUCCESS;
+}
+
+/**
+ * allocate_me_clents_storage - allocate storage for me clients
+ *
+ * @device_object - Device object for our driver
+ *
+ * @return :
+ *  0 on success,
+ *  negative on failure.
+ */
+int allocate_me_clents_storage(struct iamt_heci_device * device_object)
+{
+	long timeout = 10;	/*10 second */
+	struct heci_message_header *heci_header;
+	struct hbm_host_client_properties_request *host_cli_req;
+	__u8 client_num, i, j;
+	int err;
+	heci_header =
+	    (struct heci_message_header *) & device_object->
+	    write_message_buffer[0];
+	/* allocate storage for ME clients representation */
+	if (device_object->num_heci_me_clients > 0) {
+		kfree(device_object->me_clients);
+		device_object->me_clients =
+			    kcalloc(device_object->num_heci_me_clients,
+                        sizeof(struct heci_me_client),
+				    GFP_KERNEL);
+		if (!device_object->me_clients) {
+			device_object->heci_state = HECI_DISABLED;
+			DBG("allocate me clents  memory failed.\n");
+			return -ENOMEM;
+		}
+
+		client_num = 0;
+
+		for (i = 0; i < sizeof(device_object->heci_me_clients);
+		     i++) {
+			for (j = 0; j < 8; j++) {
+				if ((device_object->heci_me_clients[i] & (1 << j)) != 0) {
+					device_object->me_clients[client_num].client_id = (i * 8) + j;
+					device_object->me_clients[client_num].flow_control_credentials = 0;
+					heci_header->host_address = 0;
+					heci_header->me_address = 0;
+					heci_header->length = sizeof(struct hbm_host_client_properties_request);
+					heci_header->message_complete = 1;
+					heci_header->reserved = 0;
+
+					host_cli_req = (struct hbm_host_client_properties_request *)& device_object->write_message_buffer[1];
+					memset(host_cli_req, 0, sizeof(struct hbm_host_client_properties_request));
+                    host_cli_req->command.command = HOST_CLIENT_PROPERTEIS_REQ_CMD;
+					host_cli_req->address = device_object->me_clients[client_num].client_id;
+					memset(host_cli_req->reserved, 0, sizeof(host_cli_req->reserved));
+					if (!heci_write_message(device_object, heci_header,
+								(unsigned char *) (host_cli_req), heci_header->length)) {
+						DBG("send client properteis request fail.\n");
+						device_object->heci_state = HECI_DISABLED;
+						kfree(device_object->me_clients);
+						return -ENODEV;
+					}
+					/* wait for response */
+					device_object->received_message = FALSE;
+					err = wait_event_interruptible_timeout (device_object->wait_received_message,
+							(device_object->received_message), timeout * HZ);
+					if (!err && !device_object->received_message) {
+						DBG("wait_event_interruptible_timeout failed on client properteis response message.\n");
+						device_object->heci_state = HECI_DISABLED;
+						kfree(device_object->me_clients);
+						return -ENODEV;
+					}
+					device_object->received_message = FALSE;
+					client_num++;
+				}
+			}
+		}
+	}
+	return ESUCCESS;
+}
+
+/**
+ * host_init_wd - heci initialization wd.
+ *
+ * @device_object - Device object for our driver
+ *
+ * @return :
+ * none;
+ */
+void host_init_wd(struct iamt_heci_device * device_object)
+{
+	long timeout = 15;	/*15 second */
+	__u8 i;
+	int err = 0;
+	/*look for WD client and connect to it */
+	spin_lock_init(&device_object->wd_file_extension.file_lock);
+	init_waitqueue_head(&device_object->wd_file_extension.wait);
+	device_object->wd_file_extension.file = NULL;
+	device_object->wd_file_extension.state = HECI_FILE_DISCONNECTED;
+	device_object->wd_timeout = 0;
+	device_object->asf_mode = FALSE;
+	/*find ME ASF client - otherwise assume AMT mode */
+	DBG("find ME ASF client - otherwise assume AMT mode.\n");
+	for (i = 0; i < device_object->num_heci_me_clients; i++) {
+		if (memcmp(&heci_asf_guid,
+				&device_object->me_clients[i].properteis.
+				protocol_name, sizeof(struct guid))==0) {
+			device_object->asf_mode = TRUE;
+			DBG("found ME ASF client.\n");
+		}
+	}
+	if (device_object->asf_mode) {
+		memcpy(device_object->wd_data,
+		       stop_wd_params, HECI_WD_PARAMS_SIZE);
+
+	}
+        else {		/* AMT mode */
+
+		DBG("assume AMT mode.\n");
+		device_object->wd_timeout = AMT_WD_VALUE;
+		DBG("device_object->wd_timeout=%d.\n",
+		    device_object->wd_timeout);
+		memcpy(device_object->wd_data, start_wd_params, HECI_WD_PARAMS_SIZE);
+		memcpy(device_object->wd_data + HECI_WD_PARAMS_SIZE,
+		       &device_object->wd_timeout, sizeof(__u16));
+	}
+
+	/* find ME WD client */
+	for (i = 0; i < device_object->num_heci_me_clients; i++) {
+		if (0 == memcmp(&heci_wd_guid, &device_object->me_clients[i].properteis.protocol_name, sizeof(struct guid))) {
+
+			spin_lock_bh(&device_object->device_lock);
+			device_object->wd_file_extension.me_client_id =
+			    device_object->me_clients[i].client_id;
+			device_object->wd_file_extension.state =
+			    HECI_FILE_CONNECTING;
+
+			device_object->wd_file_extension.host_client_id =
+			    HECI_WD_HOST_CLIENT_ID;
+
+			device_object->wd_file_extension.
+			    flow_control_credentials = 0;
+			device_object->wd_file_extension.timer_count = 0;
+			list_add_tail(&device_object->wd_file_extension.
+				      link, &device_object->file_list);
+			spin_unlock_bh(&device_object->device_lock);
+			break;
+		}
+	}
+	DBG("check wd_file_ext\n");
+	if (HECI_FILE_CONNECTING == device_object->wd_file_extension.state) {
+		if (heci_connect(device_object,
+				 &device_object->wd_file_extension)) {
+
+			err =
+			    wait_event_timeout
+			    (device_object->wait_received_message,
+			     (HECI_FILE_CONNECTED == device_object->wd_file_extension.state ||HECI_FILE_DISCONNECTED == device_object->wd_file_extension.state),
+			     timeout * HZ);
+			if (HECI_FILE_CONNECTED == device_object->wd_file_extension.state) {
+				DBG("device_object->wd_timeout=%d.\n",
+				    device_object->wd_timeout);
+				if (device_object->wd_timeout != 0)
+					device_object->wd_due_counter = 1;
+				else
+					device_object->wd_due_counter = 0;
+				DBG("successfully to connect to WD client.\n");
+			} else {
+
+				heci_remove_client_from_file_list
+				    (device_object,
+				     device_object->wd_file_extension.
+				     host_client_id);
+				if (HECI_FILE_CONNECTED !=
+				    device_object->wd_file_extension.state)
+					DBG("wrong status received for WD client.\n");
+				if (!err)
+					DBG("wait_event_interruptible_timeout failed on client connect message fw response message err=%08x\n", err);
+				DBG("failed to connect to WD client.\n");
+				device_object->wd_file_extension.state =
+				    HECI_FILE_DISCONNECTED;
+			}
+		} else {
+			DBG("failed to call heci_connect for wd_file_extension.\n");
+			heci_remove_client_from_file_list(device_object,
+							  device_object->
+							  wd_file_extension.
+							  host_client_id);
+			device_object->wd_file_extension.state =
+			    HECI_FILE_DISCONNECTED;
+		}
+	} else {
+		DBG("failed to find WD client.\n");
+	}
+
+	device_object->wd_timer.function = &heci_wd_timer;
+	device_object->wd_timer.data = (unsigned long) device_object;
+	return;
+}
+
+
+/**
+ * host_init_legacy - heci initialization legacy client.
+ *
+ * @device_object - Device object for our driver
+ *
+ * @return :
+ * none;
+ */
+void host_init_legacy(struct iamt_heci_device * device_object)
+{
+	long timeout = 15;	/*15 second */
+	__u8 i;
+	int err;
+
+
+	spin_lock_init(&device_object->legacy_file_extension.file_lock);
+	init_waitqueue_head(&device_object->legacy_file_extension.wait);
+	spin_lock_init(&device_object->legacy_file_extension.read_io_lock);
+	spin_lock_init(&device_object->legacy_file_extension.
+		       write_io_lock);
+	init_waitqueue_head(&device_object->legacy_file_extension.rx_wait);
+	init_waitqueue_head(&device_object->legacy_file_extension.tx_wait);
+	device_object->legacy_file_extension.reading_state = HECI_IDLE;
+	device_object->legacy_file_extension.writing_state = HECI_IDLE;
+	device_object->legacy_file_extension.read_pending = FALSE;
+	device_object->legacy_file_extension.flow_control_credentials = 0;
+	device_object->legacy_file_extension.read_cb = NULL;
+	/* look for legacy client and connect to it */
+	device_object->legacy_file_extension.file = NULL;
+	device_object->legacy_file_extension.state =
+	    HECI_FILE_DISCONNECTED;
+
+	/* find ME PTHI client */
+	for (i = 0; i < device_object->num_heci_me_clients; i++) {
+		if (0 == memcmp(&heci_pthi_guid, &device_object->me_clients[i].properteis.  protocol_name, sizeof(struct guid))) {
+			spin_lock_bh(&device_object->device_lock);
+			device_object->legacy_file_extension.me_client_id =
+			    device_object->me_clients[i].client_id;
+			device_object->legacy_file_extension.state =
+			    HECI_FILE_CONNECTING;
+			device_object->legacy_file_extension.
+			    host_client_id = HECI_LEGACY_HOST_CLIENT_ID;
+			device_object->legacy_file_extension.
+			    flow_control_credentials = 0;
+			device_object->legacy_file_extension.timer_count = 0;
+			list_add_tail(&device_object->
+				      legacy_file_extension.link,
+				      &device_object->file_list);
+			spin_unlock_bh(&device_object->device_lock);
+			break;
+		}
+	}
+	if (device_object->asf_mode){
+		device_object->legacy_file_extension.state =
+			HECI_FILE_DISCONNECTED;
+		heci_remove_client_from_file_list(device_object,
+				device_object->
+				legacy_file_extension.
+				host_client_id);
+		return;
+
+	}
+	if (device_object->legacy_file_extension.state == HECI_FILE_CONNECTING) {
+		BUG_ON(device_object->me_clients[i].properteis.max_message_length != LEGACY_MTU);
+
+		if (device_object->me_clients[i].properteis.max_message_length < LEGACY_MTU) {
+			device_object->legacy_file_extension.state =
+			    HECI_FILE_DISCONNECTED;
+			DBG("legacy client buffer too small.\n");
+		} else {
+			if (heci_connect(device_object, &device_object-> legacy_file_extension)) {
+				err = wait_event_timeout (device_object->wait_received_message,
+					      (device_object->legacy_file_extension.state == HECI_FILE_CONNECTED ||
+					      device_object->legacy_file_extension.state == HECI_FILE_DISCONNECTED), timeout * HZ);
+				if ((device_object->legacy_file_extension.state != HECI_FILE_CONNECTED)) {
+					heci_remove_client_from_file_list
+					    (device_object,
+					     device_object->
+					     legacy_file_extension.
+					     host_client_id);
+					DBG("failed to connect to legacy client.\n");
+					device_object->
+					    legacy_file_extension.state =
+					    HECI_FILE_DISCONNECTED;
+				} else {
+					DBG("successfully to connect to legacy client.\n");
+					device_object->legacy_state =
+					    HECI_LEGACY_IDLE;
+				}
+			} else {
+				DBG("failed to call heci_connect for legacy_file_extension.\n");
+				heci_remove_client_from_file_list
+				    (device_object,
+				     device_object->legacy_file_extension.
+				     host_client_id);
+				device_object->legacy_file_extension.
+				    state = HECI_FILE_DISCONNECTED;
+			}
+		}
+	} else {
+		if (!device_object->asf_mode)
+			DBG("failed to find legacy client.\n");
+	}
+	return;
+}
+
+/**
+ * alloc_priv - allocates a private file structure and set it up.
+ * @file: the file structure
+ *
+ * @return :
+ * The allocated file or NULL on failure
+ */
+struct heci_file_private *alloc_priv(struct file * file)
+{
+	struct heci_file_private *priv;
+
+	priv = kmalloc(sizeof(struct heci_file_private), GFP_KERNEL);
+	if (!priv)
+		return NULL;
+
+	spin_lock_init(&priv->file_lock);
+	spin_lock_init(&priv->read_io_lock);
+	spin_lock_init(&priv->write_io_lock);
+	init_waitqueue_head(&priv->wait);
+	init_waitqueue_head(&priv->rx_wait);
+	DBG("priv->rx_wait =%p\n", &priv->rx_wait);
+	init_waitqueue_head(&priv->tx_wait);
+	INIT_LIST_HEAD(&priv->link);
+	priv->reading_state = HECI_IDLE;
+	priv->writing_state = HECI_IDLE;
+	priv->file = file;
+	priv->flow_control_credentials = 0;
+	priv->timer_count = 0;
+	priv->me_client_id = 0;
+	priv->read_cb = NULL;
+	priv->status = ESUCCESS;
+	priv->read_pending = FALSE;
+	return priv;
+}
+
+
+
+/**
+ * heci_disconnect_host_client  - send disconnect message  to fw from host client.
+ *
+ * @device_object -Device object for our driver
+ * @file_extension -extension of the file object
+ *
+ * @return :
+ *  0 on success,
+ *  negative on failure.
+ */
+int heci_disconnect_host_client(struct iamt_heci_device * device_object,
+				struct heci_file_private * file_extension)
+{
+	int return_status = ESUCCESS, err = 0;
+	long timeout = 15;	/*15 second */
+
+	struct heci_cb_private *kernel_priv_cb = NULL;
+
+	struct heci_file_private *file_extension_list_temp = NULL;
+
+       struct heci_cb_private *kernel_priv_cb_pos = NULL, *kernel_priv_cb_next = NULL;
+
+	if ((!device_object) || (!file_extension))
+		return -ENODEV;
+	kernel_priv_cb = kmalloc(sizeof(struct heci_cb_private), GFP_KERNEL);
+	if (!kernel_priv_cb)
+		return -ENOMEM;
+	if (file_extension->state == HECI_FILE_DISCONNECTING) {
+		INIT_LIST_HEAD(&kernel_priv_cb->cb_list);
+		kernel_priv_cb->file_private = file_extension;
+		kernel_priv_cb->major_file_operations = HECI_CLOSE;
+		spin_lock_bh(&device_object->device_lock);
+		if (device_object->host_buffer_is_empty){
+                    device_object->host_buffer_is_empty =FALSE;
+                    if (heci_disconnect(device_object, file_extension)) {
+			    list_add_tail(&kernel_priv_cb->cb_list,
+				      &device_object->control_read_list.
+				      heci_cb.cb_list);
+                     }
+                     else{
+                             spin_unlock_bh(&device_object->device_lock);
+			        return_status = -ENODEV;
+			        DBG("failed to call heci_disconnect for file_extension.\n");
+                             goto free;
+                      }
+		 }
+               else{
+                    kernel_priv_cb->file_private = file_extension;
+		        DBG("add disconnect cb to control write list\n");
+		        list_add_tail(&kernel_priv_cb->cb_list,
+			      &device_object->control_write_list.heci_cb.cb_list);
+               }
+	        spin_unlock_bh(&device_object->device_lock);
+
+		 err =
+		    wait_event_timeout
+		    (device_object->wait_received_message,
+		     (HECI_FILE_DISCONNECTED == file_extension->state),
+		     timeout * HZ);
+		if (HECI_FILE_DISCONNECTED == file_extension->state) {
+			return_status = ESUCCESS;
+			DBG("successfully to disconnect from fw client.\n");
+		} else {
+			return_status = -ENODEV;
+			if (HECI_FILE_DISCONNECTED != file_extension->state)
+				DBG("wrong status received for client disconnect.\n");
+			if (!err)
+				DBG("wait_event_interruptible_timeout failed on client disconnect message fw response message err=%08x\n", err);
+			DBG("failed to diconnect to fw client.\n");
+		}
+
+	}
+	if (kernel_priv_cb) {
+		spin_lock_bh(&device_object->device_lock);
+		if (device_object->control_read_list.status == ESUCCESS
+		    && !list_empty(&device_object->control_read_list.heci_cb.cb_list)) {
+		    list_for_each_entry_safe(kernel_priv_cb_pos, kernel_priv_cb_next, &device_object->control_read_list.heci_cb.cb_list, cb_list){
+				file_extension_list_temp =
+				    (struct heci_file_private *)
+				    kernel_priv_cb_pos->file_private;
+				if (file_extension_list_temp) {
+					if ((file_extension->host_client_id == file_extension_list_temp->host_client_id)
+						&& (file_extension->me_client_id == file_extension_list_temp->me_client_id)) {
+						list_del(&kernel_priv_cb_pos->cb_list);
+					}
+				}
+
+			}
+		}
+		spin_unlock_bh(&device_object->device_lock);
+free:
+              kfree(kernel_priv_cb);
+		kernel_priv_cb = NULL;
+
+
+	}
+
+    return return_status;
+}
+
+
+/**
+ * heci_remove_client_from_file_list  - remove file extension from device file list
+ *
+ * @device_object -Device object for our driver
+ * @host_client_id   -host client id to be removed
+ *
+ * @return :
+ * none;
+ */
+void heci_remove_client_from_file_list(struct iamt_heci_device * device_object,
+				       __u8 host_client_id)
+{
+	struct heci_file_private *file_extension_pos = NULL;
+	struct heci_file_private *file_extension_next = NULL;
+	list_for_each_entry_safe(file_extension_pos, file_extension_next, &device_object->file_list, link) {
+		if (host_client_id == file_extension_pos->host_client_id) {
+			DBG("remove  file extension node host client = %d, ME client = %d\n",
+					file_extension_pos->host_client_id,
+					file_extension_pos->me_client_id);
+			list_del(&file_extension_pos->link);
+			break;
+		}
+
+
+	}
+}
diff -Nurp linux-2.6.37/3rdparty/heci/heci_interface.c linux-2.6.37.3rdparty/3rdparty/heci/heci_interface.c
--- linux-2.6.37/3rdparty/heci/heci_interface.c	1970-01-01 02:00:00.000000000 +0200
+++ linux-2.6.37.3rdparty/3rdparty/heci/heci_interface.c	2008-01-24 14:04:22.000000000 +0200
@@ -0,0 +1,525 @@
+/*
+ * Part of Intel(R) Manageability Engine Interface Linux driver
+ *
+ * Copyright (c) 2003 - 2007 Intel Corp.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions, and the following disclaimer,
+ *    without modification.
+ * 2. Redistributions in binary form must reproduce at minimum a disclaimer
+ *    substantially similar to the "NO WARRANTY" disclaimer below
+ *    ("Disclaimer") and any redistribution must be conditioned upon
+ *    including a substantially similar Disclaimer requirement for further
+ *    binary redistribution.
+ * 3. Neither the names of the above-listed copyright holders nor the names
+ *    of any contributors may be used to endorse or promote products derived
+ *    from this software without specific prior written permission.
+ *
+ * Alternatively, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") version 2 as published by the Free
+ * Software Foundation.
+ *
+ * NO WARRANTY
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGES.
+ *
+ */
+
+
+#include "heci.h"
+#include "heci_interface.h"
+
+
+
+static const __u8 interface_start_wd_params[] =
+    { 0x02, 0x12, 0x13, 0x10 };
+static const __u8 interface_stop_wd_params[] =
+    { 0x02, 0x02, 0x14, 0x10 };
+
+/**
+ * read_heci_register - Read a byte from the heci device
+ * @device: the device structure
+ * @offset: offset from which to read the data
+ *
+ * Return:
+ * the byte read.
+ */
+__u32 read_heci_register(struct iamt_heci_device * device,
+			    unsigned long offset)
+{
+    return readl(device->mem_addr + offset);
+}
+
+/**
+ * write_heci_register - Write  4 bytes to the heci device
+ * @device: the device structure
+ * @offset: offset from which to write the data
+ *
+ * @value: the byte to write
+ */
+void write_heci_register(struct iamt_heci_device * device, unsigned long offset,
+			 __u32 value)
+{
+    writel(value, device->mem_addr + offset);
+}
+
+/**
+ * host_buffer_is_empty  - check if host buffer is empty.
+ *
+ * @device_object -Device object for our driver
+ *
+ * @return :
+ * TRUE if empty
+ * FALSE - otherwise.
+ */
+int host_buffer_is_empty(struct iamt_heci_device * device_object)
+{
+	char read_ptr, write_ptr;
+	unsigned char buffer_depth, filled_slots, empty_slots;
+	device_object->host_hw_state =
+	    read_heci_register(device_object, H_CSR);
+	read_ptr = (char) ((device_object->host_hw_state & H_CBRP) >> 8);
+	write_ptr = (char) ((device_object->host_hw_state & H_CBWP) >> 16);
+	buffer_depth =
+	    (unsigned char) ((device_object->host_hw_state & H_CBD) >> 24);
+	filled_slots = (unsigned char) (write_ptr - read_ptr);
+	empty_slots = buffer_depth - filled_slots;
+
+	if (filled_slots > 0)
+		return FALSE;
+	return TRUE;
+}
+
+/**
+ * count_empty_write_slots  - count write empty slots.
+ *
+ * @device_object - Device object for our driver
+ *
+ *
+ * @return :
+ *  -1(ESLOTS_OVERFLOW) if overflow
+ *  otherwise filed slots count
+ */
+__s32 count_empty_write_slots(struct iamt_heci_device * device_object)
+{
+	char read_ptr, write_ptr;
+	unsigned char buffer_depth, filled_slots, empty_slots;
+
+	read_ptr = (char) ((device_object->host_hw_state & H_CBRP) >> 8);
+	write_ptr = (char) ((device_object->host_hw_state & H_CBWP) >> 16);
+	buffer_depth =
+	    (unsigned char) ((device_object->host_hw_state & H_CBD) >> 24);
+	filled_slots = (unsigned char) (write_ptr - read_ptr);
+	empty_slots = buffer_depth - filled_slots;
+
+	if (filled_slots > buffer_depth)
+		/* overfolw */
+		return -ESLOTS_OVERFLOW;
+
+	return (__s32) empty_slots;
+}
+
+/**
+ * heci_write_message  - write a message to heci device.
+ *
+ * @heci_header          - header of  message
+ * @write_buffer         - message buffer will be write
+ * @write_length         - message size will be write
+ *
+ * @return :
+ * TRUE if success
+ * FALSE - otherwise.
+ */
+int heci_write_message(struct iamt_heci_device * device_object,
+			     struct heci_message_header * header,
+			     unsigned char *write_buffer,
+			     unsigned long write_length)
+{
+	__u32 temp_msg = 0;
+	unsigned long bytes_written = 0;
+	char read_ptr, write_ptr;
+	unsigned char buffer_depth, filled_slots, empty_slots;
+	unsigned long dw_to_write;
+	dw_to_write = ((write_length + 3) / 4);
+	DBG("host_hw_state = 0x%08x.\n", device_object->host_hw_state);
+	DBG("heci_write_message header=%08x.\n", *((__u32 *) header));
+
+	read_ptr = (char) ((device_object->host_hw_state & H_CBRP) >> 8);
+	write_ptr = (char) ((device_object->host_hw_state & H_CBWP) >> 16);
+	buffer_depth =
+	    (unsigned char) ((device_object->host_hw_state & H_CBD) >> 24);
+	filled_slots = (unsigned char) (write_ptr - read_ptr);
+	empty_slots = buffer_depth - filled_slots;
+	DBG("filled = %hu, empty = %hu.\n", filled_slots, empty_slots);
+
+	if (dw_to_write > empty_slots) {
+		return FALSE;
+	}
+
+	write_heci_register(device_object, H_CB_WW,
+			    *((__u32 *) header));
+
+	while (write_length >= 4) {
+		write_heci_register(device_object, H_CB_WW,
+				    *(__u32 *) (write_buffer +
+						   bytes_written));
+		bytes_written += 4;
+		write_length -= 4;
+	}
+
+	if (write_length > 0) {
+		memcpy(&temp_msg, &write_buffer[bytes_written], write_length);
+		write_heci_register(device_object, H_CB_WW, temp_msg);
+	}
+
+	device_object->host_hw_state |= H_IG;
+	write_heci_register(device_object, H_CSR,
+			    device_object->host_hw_state);
+	device_object->me_hw_state =
+	    read_heci_register(device_object, ME_CSR_HA);
+	if ((device_object->me_hw_state & ME_RDY_HRA) != ME_RDY_HRA)
+		return FALSE;
+
+	device_object->write_hang = 0;
+	return TRUE;
+}
+
+/**
+ * count_full_read_slots  - reset host and fw.
+ *
+ * @device_object -Device object for our driver
+ *
+ *
+ * @return :
+ * -1(ESLOTS_OVERFLOW) if overflow
+ * otherwise filed slots count
+ */
+__s32 count_full_read_slots(struct iamt_heci_device * device_object)
+{
+
+	char read_ptr, write_ptr;
+	unsigned char buffer_depth, filled_slots, empty_slots;
+
+	device_object->me_hw_state = read_heci_register(device_object, ME_CSR_HA);
+	read_ptr = (char) ((device_object->me_hw_state & ME_CBRP_HRA) >> 8);
+	write_ptr = (char) ((device_object->me_hw_state & ME_CBWP_HRA) >> 16);
+	buffer_depth = (unsigned char) ((device_object->me_hw_state & ME_CBD_HRA) >>
+			     24);
+	filled_slots = (unsigned char) (write_ptr - read_ptr);
+	empty_slots = buffer_depth - filled_slots;
+
+	if (filled_slots > buffer_depth)
+		/* overflow */
+		return -ESLOTS_OVERFLOW;
+
+	DBG("filled_slots =%08x  \n", filled_slots);
+	return (__s32) filled_slots;
+}
+
+/**
+ * heci_read_slots  - read a message from heci device.
+ *
+ * @device_object  - device object for our driver
+ * @buffer         - message buffer will be write
+ * @buffer_length  - message size will be read
+ *
+ * @return :
+ * none;
+ */
+void heci_read_slots(struct iamt_heci_device * device_object,
+		     unsigned char *buffer, unsigned long buffer_length)
+{
+	__u32 i = 0;
+	unsigned char temp_buf[sizeof(__u32)];
+
+	while (buffer_length >= sizeof(__u32)) {
+		((__u32 *) buffer)[i] =
+		    read_heci_register(device_object, ME_CB_RW);
+		DBG("buffer[%d]= %d\n", i, ((__u32 *) buffer)[i]);
+		i++;
+		buffer_length -= sizeof(__u32);
+	}
+
+	if (buffer_length > 0) {
+		*((__u32 *) & temp_buf) =
+		    read_heci_register(device_object, ME_CB_RW);
+		memcpy(&buffer[i * 4], temp_buf, buffer_length);
+	}
+
+	device_object->host_hw_state |= H_IG;
+	write_heci_register(device_object, H_CSR,
+			    device_object->host_hw_state);
+	return;
+}
+
+/**
+ * flow_control_credentials  - check flow_control credentials.
+ *
+ * @device_object -Device object for our driver
+ * @file_extension -extension of the file object
+ *
+ * @return :
+ * TRUE if flow_control_credentials >0
+ * FALSE - otherwise.
+ */
+int flow_control_credentials(struct iamt_heci_device * device_object,
+				   struct heci_file_private * file_extension)
+{
+	__u8 i;
+
+	if (!device_object->num_heci_me_clients)
+		return FALSE;
+	if (file_extension == NULL)
+		return FALSE;
+	if (file_extension->flow_control_credentials > 0)
+		return TRUE;
+
+	for (i = 0; i < device_object->num_heci_me_clients; i++) {
+		if (device_object->me_clients[i].client_id ==
+		    file_extension->me_client_id) {
+			if (device_object->me_clients[i].flow_control_credentials > 0) {
+				BUG_ON(device_object->me_clients[i].
+				       properteis.single_receive_buffer == 0);
+				return TRUE;
+			}
+			return FALSE;
+		}
+	}
+	BUG_ON(1);
+	return FALSE;
+}
+
+/**
+ * flow_control_reduce  - reduce flow_control .
+ *
+ * @device_object -Device object for our driver
+ * @file_extension -extension of the file object
+ *
+ * @return :
+ * none;
+ */
+void flow_control_reduce(struct iamt_heci_device * device_object,
+			 struct heci_file_private * file_extension)
+{
+	__u8 i;
+
+	if (!device_object->num_heci_me_clients)
+		return;
+
+	for (i = 0; i < device_object->num_heci_me_clients; i++) {
+		if (device_object->me_clients[i].client_id == file_extension->me_client_id) {
+			if (device_object->me_clients[i].properteis.single_receive_buffer != 0) {
+				BUG_ON(device_object->me_clients[i].
+				       flow_control_credentials <= 0);
+				device_object->me_clients[i].
+				    flow_control_credentials--;
+			} else {
+				BUG_ON(file_extension->
+				       flow_control_credentials <= 0);
+				file_extension->flow_control_credentials--;
+			}
+			return;
+		}
+	}
+	BUG_ON(1);
+}
+
+/**
+ * heci_send_flow_control  - send flow control to fw.
+ *
+ * @device_object -Device object for our driver
+ * @file_extension -extension of the file object
+ *
+ * @return :
+ * TRUE if success
+ * FALSE - otherwise.
+ */
+int heci_send_flow_control(struct iamt_heci_device * device_object,
+				 struct heci_file_private * file_extension)
+{
+	struct heci_message_header *heci_header;
+	struct hbm_flow_control *heci_flow_control;
+
+	heci_header =
+	    (struct heci_message_header *) & device_object->
+	    write_message_buffer[0];
+	heci_header->host_address = 0;
+	heci_header->me_address = 0;
+	heci_header->length = sizeof(struct hbm_flow_control);
+	heci_header->message_complete = 1;
+	heci_header->reserved = 0;
+
+	heci_flow_control =
+	    (struct hbm_flow_control *) & device_object->
+	    write_message_buffer[1];
+	memset(heci_flow_control, 0, sizeof(heci_flow_control));
+	heci_flow_control->host_address = file_extension->host_client_id;
+	heci_flow_control->me_address = file_extension->me_client_id;
+	heci_flow_control->command.command = FLOW_CONTROL_CMD;
+	memset(heci_flow_control->reserved, 0, sizeof(heci_flow_control->reserved));
+	DBG("sending flow control host client = %d, me client = %d\n",
+	    file_extension->host_client_id, file_extension->me_client_id);
+	if (!heci_write_message(device_object, heci_header,
+			       (unsigned char *) heci_flow_control, sizeof(struct hbm_flow_control)))
+		return FALSE;
+	return TRUE;
+
+}
+
+/**
+ * other_client_is_connecting  - check if other
+ * client with the same client id is connected.
+ *
+ * @device_object -Device object for our driver
+ * @file_extension -extension of the file object
+ *
+ * @return :
+ * TRUE if other client is connected.
+ * FALSE - otherwise.
+ */
+int other_client_is_connecting(struct iamt_heci_device * device_object,
+				     struct heci_file_private * file_extension)
+{
+
+	struct heci_file_private *file_extension_pos = NULL;
+	struct heci_file_private *file_extension_next = NULL;
+        list_for_each_entry_safe(file_extension_pos, file_extension_next, &device_object->file_list, link) {
+		if ((file_extension_pos->state == HECI_FILE_CONNECTING)
+		    && (file_extension_pos != file_extension)
+		    && file_extension->me_client_id ==
+		    file_extension_pos->me_client_id)
+			return TRUE;
+	}
+	return FALSE;
+}
+
+/**
+ * heci_send_wd  - send watch dog message to fw.
+ *
+ * @device_object -Device object for our driver
+ *
+ * @return :
+ * TRUE if success
+ * FALSE - otherwise.
+ */
+int heci_send_wd(struct iamt_heci_device * device_object)
+{
+	struct heci_message_header *heci_header;
+
+	heci_header =
+	    (struct heci_message_header *) & device_object->
+	    write_message_buffer[0];
+	heci_header->host_address =
+	    device_object->wd_file_extension.host_client_id;
+	heci_header->me_address =
+	    device_object->wd_file_extension.me_client_id;
+	heci_header->message_complete = 1;
+	heci_header->reserved = 0;
+
+	if (!memcmp(device_object->wd_data, interface_start_wd_params,
+	     HECI_WD_PARAMS_SIZE)) {
+		heci_header->length = HECI_START_WD_DATA_SIZE;
+	} else {
+		BUG_ON(memcmp(device_object->wd_data, interface_stop_wd_params,
+			HECI_WD_PARAMS_SIZE));
+		heci_header->length = HECI_WD_PARAMS_SIZE;
+	}
+
+	if (!heci_write_message(device_object, heci_header,
+			       device_object->wd_data,
+			       heci_header->length))
+		return FALSE;
+	return TRUE;
+}
+
+
+/**
+ * heci_disconnect  - send disconnect message  to fw.
+ *
+ * @device_object -Device object for our driver
+ * @file_extension -extension of the file object
+ *
+ * @return :
+ * TRUE if success
+ * FALSE - otherwise.
+ */
+int heci_disconnect(struct iamt_heci_device * device_object,
+			  struct heci_file_private * file_extension)
+{
+	struct heci_message_header *heci_header;
+	struct hbm_client_disconnect_request *heci_cli_disconnect;
+
+	heci_header =
+	    (struct heci_message_header *) & device_object->
+	    write_message_buffer[0];
+	heci_header->host_address = 0;
+	heci_header->me_address = 0;
+	heci_header->length = sizeof(struct hbm_client_disconnect_request);
+	heci_header->message_complete = 1;
+	heci_header->reserved = 0;
+
+	heci_cli_disconnect =
+	    (struct hbm_client_disconnect_request *) & device_object->
+	    write_message_buffer[1];
+	memset(heci_cli_disconnect, 0, sizeof(heci_cli_disconnect));
+	heci_cli_disconnect->host_address = file_extension->host_client_id;
+	heci_cli_disconnect->me_address = file_extension->me_client_id;
+	heci_cli_disconnect->command.command = CLIENT_DISCONNECT_REQ_CMD;
+	heci_cli_disconnect->reserved[0] = 0;
+
+	if (TRUE != heci_write_message(device_object, heci_header,
+			       (unsigned char *) heci_cli_disconnect, sizeof(struct hbm_client_disconnect_request)))
+		return FALSE;
+	return TRUE;
+}
+
+/**
+ * heci_connect  - send connect message  to fw.
+ *
+ * @device_object -Device object for our driver
+ * @file_extension -extension of the file object
+ *
+ * @return :
+ * TRUE if success
+ * FALSE - otherwise.
+ */
+int heci_connect(struct iamt_heci_device * device_object,
+		       struct heci_file_private * file_extension)
+{
+	struct heci_message_header *heci_header;
+	struct hbm_client_connect_request *heci_cli_connect;
+
+	heci_header =
+	    (struct heci_message_header *) & device_object->
+	    write_message_buffer[0];
+	heci_header->host_address = 0;
+	heci_header->me_address = 0;
+	heci_header->length = sizeof(struct hbm_client_connect_request);
+	heci_header->message_complete = 1;
+	heci_header->reserved = 0;
+
+	heci_cli_connect =
+	    (struct hbm_client_connect_request *) & device_object->
+	    write_message_buffer[1];
+	heci_cli_connect->host_address = file_extension->host_client_id;
+	heci_cli_connect->me_address = file_extension->me_client_id;
+	heci_cli_connect->command.command = CLIENT_CONNECT_REQ_CMD;
+	heci_cli_connect->reserved = 0;
+	if (TRUE != heci_write_message(device_object, heci_header,
+			       (unsigned char *) heci_cli_connect, sizeof(struct hbm_client_connect_request)))
+		return FALSE;
+	return TRUE;
+}
diff -Nurp linux-2.6.37/3rdparty/heci/heci_interface.h linux-2.6.37.3rdparty/3rdparty/heci/heci_interface.h
--- linux-2.6.37/3rdparty/heci/heci_interface.h	1970-01-01 02:00:00.000000000 +0200
+++ linux-2.6.37.3rdparty/3rdparty/heci/heci_interface.h	2008-01-24 14:04:22.000000000 +0200
@@ -0,0 +1,177 @@
+/*
+ * Part of Intel(R) Manageability Engine Interface Linux driver
+ *
+ * Copyright (c) 2003 - 2007 Intel Corp.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions, and the following disclaimer,
+ *    without modification.
+ * 2. Redistributions in binary form must reproduce at minimum a disclaimer
+ *    substantially similar to the "NO WARRANTY" disclaimer below
+ *    ("Disclaimer") and any redistribution must be conditioned upon
+ *    including a substantially similar Disclaimer requirement for further
+ *    binary redistribution.
+ * 3. Neither the names of the above-listed copyright holders nor the names
+ *    of any contributors may be used to endorse or promote products derived
+ *    from this software without specific prior written permission.
+ *
+ * Alternatively, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") version 2 as published by the Free
+ * Software Foundation.
+ *
+ * NO WARRANTY
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGES.
+ *
+ */
+
+
+#ifndef _HECI_INTERFACE_H_
+#define _HECI_INTERFACE_H_
+
+#include <linux/version.h>
+#include <linux/spinlock.h>
+#include <linux/list.h>
+#include <linux/pci.h>
+#include <linux/timer.h>
+#include <linux/interrupt.h>
+#include <linux/workqueue.h>
+#include <linux/module.h>
+#include <linux/aio.h>
+#include <linux/types.h>
+#include "heci_data_structures.h"
+
+
+#define HBM_MINOR_VERSION                   0
+#define HBM_MAJOR_VERSION                   1
+#define HBM_TIMEOUT                         1	/* 1 second */
+
+
+#define HOST_START_REQ_CMD                  0x01
+#define HOST_START_RES_CMD                  0x81
+
+#define HOST_STOP_REQ_CMD                   0x02
+#define HOST_STOP_RES_CMD                   0x82
+
+#define ME_STOP_REQ_CMD                     0x03
+
+#define HOST_ENUM_REQ_CMD                   0x04
+#define HOST_ENUM_RES_CMD                   0x84
+
+#define HOST_CLIENT_PROPERTEIS_REQ_CMD      0x05
+#define HOST_CLIENT_PROPERTEIS_RES_CMD      0x85
+
+#define CLIENT_CONNECT_REQ_CMD              0x06
+#define CLIENT_CONNECT_RES_CMD              0x86
+
+#define CLIENT_DISCONNECT_REQ_CMD           0x07
+#define CLIENT_DISCONNECT_RES_CMD           0x87
+
+#define FLOW_CONTROL_CMD                    0x08
+
+
+#define AMT_WD_VALUE 120	/* seconds */
+
+#define HECI_WATCHDOG_DATA_SIZE         16
+#define HECI_START_WD_DATA_SIZE         20
+#define HECI_WD_PARAMS_SIZE             4
+
+/* IOCTL commands */
+#define HECI_IOCTL_LETTER 'H'
+
+
+#define IOCTL_HECI_GET_VERSION \
+    _IOWR(HECI_IOCTL_LETTER , 0x800, struct heci_message_data)
+#define IOCTL_HECI_CONNECT_CLIENT \
+    _IOWR(HECI_IOCTL_LETTER , 0x801, struct heci_message_data)
+#define IOCTL_HECI_WD \
+    _IOWR(HECI_IOCTL_LETTER , 0x802, struct heci_message_data)
+#define IOCTL_HECI_BYPASS_WD \
+    _IOWR(HECI_IOCTL_LETTER , 0x810, struct heci_message_data)
+
+#define IAMT_IOC_MAGIC 'i'
+#define IAMT_KCS_SEND_MESSAGE_COMMAND _IOR(IAMT_IOC_MAGIC, 1, struct heci_message_data)
+#define IAMT_KCS_RECEIVE_MESSAGE_COMMAND _IOW(IAMT_IOC_MAGIC, 2, struct heci_message_data)
+
+
+#pragma pack(1)
+
+
+enum heci_stop_reason_types{
+	DRIVER_STOP_REQUEST = 0x00,
+	DEVICE_D1_ENTRY = 0x01,
+	DEVICE_D2_ENTRY = 0x02,
+	DEVICE_D3_ENTRY = 0x03,
+	SYSTEM_S1_ENTRY = 0x04,
+	SYSTEM_S2_ENTRY = 0x05,
+	SYSTEM_S3_ENTRY = 0x06,
+	SYSTEM_S4_ENTRY = 0x07,
+	SYSTEM_S5_ENTRY = 0x08
+};
+
+enum me_stop_reason_types{
+	FW_UPDATE = 0x00
+};
+
+enum client_connect_status_types{
+	CCS_SUCCESS = 0x00,
+	CCS_NOT_FOUND = 0x01,
+	CCS_ALREADY_STARTED = 0x02,
+	CCS_OUT_OF_RESOURCES = 0x03,
+	CCS_MESSAGE_SMALL = 0x04
+};
+
+enum client_disconnect_status_types{
+	CDS_SUCCESS = 0x00
+};
+
+
+/**
+ * heci interface function prototypes
+ */
+void heci_read_slots(struct iamt_heci_device * device_object,
+		     unsigned char *buffer, unsigned long buffer_length);
+
+int heci_write_message(struct iamt_heci_device * device_object,
+			     struct heci_message_header * header,
+			     unsigned char *write_buffer,
+			     unsigned long write_length);
+
+int host_buffer_is_empty(struct iamt_heci_device * device_object);
+
+__s32 count_full_read_slots(struct iamt_heci_device * device_object);
+
+__s32 count_empty_write_slots(struct iamt_heci_device * device_object);
+
+int flow_control_credentials(struct iamt_heci_device * device_object,
+				   struct heci_file_private * file_extension);
+
+int heci_send_wd(struct iamt_heci_device * device_object);
+
+void flow_control_reduce(struct iamt_heci_device * device_object,
+			 struct heci_file_private * file_extension);
+
+int heci_send_flow_control(struct iamt_heci_device * device_object,
+				 struct heci_file_private * file_extension);
+
+int heci_disconnect(struct iamt_heci_device * device_object,
+			  struct heci_file_private * file_extension);
+int other_client_is_connecting(struct iamt_heci_device * device_object,
+				     struct heci_file_private * file_extension);
+int heci_connect(struct iamt_heci_device * device_object,
+		       struct heci_file_private * file_extension);
+
+#endif				/* _HECI_INTERFACE_H_ */
diff -Nurp linux-2.6.37/3rdparty/heci/heci_main.c linux-2.6.37.3rdparty/3rdparty/heci/heci_main.c
--- linux-2.6.37/3rdparty/heci/heci_main.c	1970-01-01 02:00:00.000000000 +0200
+++ linux-2.6.37.3rdparty/3rdparty/heci/heci_main.c	2008-01-24 14:04:22.000000000 +0200
@@ -0,0 +1,1444 @@
+/*
+ * Part of Intel(R) Manageability Engine Interface Linux driver
+ *
+ * Copyright (c) 2003 - 2007 Intel Corp.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions, and the following disclaimer,
+ *    without modification.
+ * 2. Redistributions in binary form must reproduce at minimum a disclaimer
+ *    substantially similar to the "NO WARRANTY" disclaimer below
+ *    ("Disclaimer") and any redistribution must be conditioned upon
+ *    including a substantially similar Disclaimer requirement for further
+ *    binary redistribution.
+ * 3. Neither the names of the above-listed copyright holders nor the names
+ *    of any contributors may be used to endorse or promote products derived
+ *    from this software without specific prior written permission.
+ *
+ * Alternatively, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") version 2 as published by the Free
+ * Software Foundation.
+ *
+ * NO WARRANTY
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGES.
+ *
+ */
+
+
+#include <linux/module.h>
+#include <linux/moduleparam.h>
+#include <linux/kernel.h>
+#include <linux/slab.h>
+#include <linux/fs.h>
+#include <linux/errno.h>
+#include <linux/types.h>
+#include <linux/fcntl.h>
+#include <linux/aio.h>
+#include <linux/pci.h>
+#include <linux/reboot.h>
+#include <linux/poll.h>
+#include <linux/init.h>
+#include <linux/kdev_t.h>
+#include <linux/ioctl.h>
+#include <linux/cdev.h>
+#include <asm/uaccess.h>
+#include <asm/unistd.h>
+
+#include "kcompat.h"
+#include "heci.h"
+#include "heci_interface.h"
+#include "version.h"
+
+
+#define HECI_READ_TIMEOUT	45
+
+#define  MAX_OPEN_HANDLE_COUNT			253
+/**
+ *  heci driver strings
+ */
+char heci_driver_name[] = "heci";
+char heci_driver_string[] = "Intel(R) AMT Management Interface";
+char heci_driver_version[] = DRIVER_VERSION;
+char heci_copyright[] = "Copyright (c) 2003 - 2007 Intel Corporation.";
+
+
+#ifdef HECI_DEBUG
+DEF_PARM(int, debug, 1, 0644, "Debug enabled or not");
+#else
+DEF_PARM(int, debug, 0, 0644, "Debug enabled or not");
+#endif
+
+/* heci char device for registration */
+static struct cdev heci_cdev = {
+	.kobj = {.name = "heci", },
+	.owner = THIS_MODULE,
+};
+
+/* iamt legacy char device for registration */
+static struct cdev iamt_legacy_cdev = {
+	.kobj = {.name = "iamt_legacy", },
+	.owner = THIS_MODULE,
+};
+
+/* major number for device */
+static int heci_major;
+/* The device pointer */
+static struct pci_dev *heci_device;
+
+/* heci_pci_tbl - PCI Device ID Table */
+static struct pci_device_id heci_pci_tbl[] = {
+	{PCI_DEVICE(PCI_VENDOR_ID_INTEL, PCI_HECI_DEVICE_ID1)},
+	{PCI_DEVICE(PCI_VENDOR_ID_INTEL, PCI_HECI_DEVICE_ID2)},
+	{PCI_DEVICE(PCI_VENDOR_ID_INTEL, PCI_HECI_DEVICE_ID3)},
+	{PCI_DEVICE(PCI_VENDOR_ID_INTEL, PCI_HECI_DEVICE_ID4)},
+	{PCI_DEVICE(PCI_VENDOR_ID_INTEL, PCI_HECI_DEVICE_ID5)},
+	{PCI_DEVICE(PCI_VENDOR_ID_INTEL, PCI_HECI_DEVICE_ID6)},
+	{PCI_DEVICE(PCI_VENDOR_ID_INTEL, PCI_HECI_DEVICE_ID7)},
+	{PCI_DEVICE(PCI_VENDOR_ID_INTEL, PCI_HECI_DEVICE_ID8)},
+	/* required last entry */
+	{0, }
+};
+
+MODULE_DEVICE_TABLE(pci, heci_pci_tbl);
+
+/**
+ * Local Function Prototypes
+ */
+static int __init heci_init_module(void);
+static void __exit heci_exit_module(void);
+static int __devinit heci_probe(struct pci_dev *pdev,
+				const struct pci_device_id *ent);
+static void __devexit heci_remove(struct pci_dev *pdev);
+static int heci_open(struct inode *inode, struct file *file);
+static int heci_release(struct inode *inode, struct file *file);
+static unsigned int heci_legacy_poll(struct file *file, poll_table * wait);
+static ssize_t heci_read(struct file *file, char __user * ubuf,
+			 size_t length, loff_t * offset);
+static int heci_ioctl(struct inode *inode, struct file *file,
+		      unsigned int cmd, unsigned long data);
+static ssize_t heci_write(struct file *file, const char __user * ubuf,
+			  size_t length, loff_t * offset);
+static unsigned int heci_poll(struct file *file, poll_table * wait);
+#ifdef CONFIG_PM
+static int heci_suspend(struct pci_dev* pdev, pm_message_t state);
+static int heci_resume(struct pci_dev* pdev);
+static __u16 g_sus_wd_timeout;
+#endif
+/**
+ *  PCI driver structure
+ */
+static struct pci_driver heci_driver = {
+	.name = heci_driver_name,
+	.id_table = heci_pci_tbl,
+	.probe = heci_probe,
+	.remove = heci_remove,
+	SHUTDOWN_METHOD(heci_remove)
+#ifdef CONFIG_PM
+	.suspend = heci_suspend, 
+	.resume = heci_resume
+#endif
+};
+
+/**
+ * file operations structure will be use heci char device.
+ */
+static struct file_operations heci_fops = {
+	.owner = THIS_MODULE,
+	.read = heci_read,
+	.ioctl = heci_ioctl,
+	.open = heci_open,
+	.release = heci_release,
+	.write = heci_write,
+	.poll = heci_poll,
+};
+
+/**
+ * file operations structure will be use iamt legacy char device.
+ */
+static struct file_operations iamt_legacy_fops = {
+	.owner = THIS_MODULE,
+	.ioctl = heci_ioctl,
+	.open = heci_open,
+	.release = heci_release,
+	.poll = heci_legacy_poll,
+};
+
+/**
+ * For kernels withouth PCI shutdown support reboot notifier is essential
+ */
+HECI_REBOOT_NOTIFIER(heci_reboot_notifier, heci_driver, heci_remove)
+
+/**
+ * Set up the cdev structure for heci device.
+ * @dev   - char device struct
+ * @minor - minor number for registration char device
+ * @fops  - file operations structure
+ * @return :
+ * 0 on success,
+ * negative on failure
+ */
+static int heci_registration_cdev(struct cdev *dev, int minor,
+				  struct file_operations *fops)
+{
+	int ret = ESUCCESS, devno = MKDEV(heci_major, minor);
+
+	cdev_init(dev, fops);
+	dev->owner = THIS_MODULE;
+	dev->ops = fops;
+	ret = cdev_add(dev, devno, 1);
+	/* Fail gracefully if need be */
+	if (ret) {
+		kobject_put(&dev->kobj);
+		ERR("Error %d registering heci device %d", ret, minor);
+	}
+	return ret;
+}
+
+
+
+/**
+ * heci_init_module - Driver Registration Routine
+ *
+ * heci_init_module is the first routine called when the driver is
+ * loaded. All it does is register with the PCI subsystem.
+ *
+ * @return :
+ * 0 on success,
+ * negative on failure
+ */
+static int __init heci_init_module(void)
+{
+	int ret = ESUCCESS;
+	dev_t dev;
+	INFO("%s - version %s\n", heci_driver_string, heci_driver_version);
+	INFO("%s\n", heci_copyright);
+
+	/* init pci module */
+	ret = pci_register_driver(&heci_driver);
+	if (ret < 0)
+		goto end;
+
+	REGISTER_REBOOT_NOTIFIER(heci_reboot_notifier);
+	/* registration char devices */
+	ret = alloc_chrdev_region(&dev, 0, MINORS_COUNT, "heci");
+
+	heci_major = MAJOR(dev);
+	/* Now registration two cdevs. */
+	ret = heci_registration_cdev(&iamt_legacy_cdev, LEGACY_MINOR_NUMBER,
+				   &iamt_legacy_fops);
+	if (ret)
+		goto unregister;
+
+	ret = heci_registration_cdev(&heci_cdev, HECI_MINOR_NUMBER,
+				   &heci_fops);
+	if (ret) {
+		cdev_del(&iamt_legacy_cdev);
+		goto unregister;
+	}
+	return ret;
+
+unregister:
+	pci_unregister_driver(&heci_driver);
+	unregister_chrdev_region(MKDEV(heci_major, 0), MINORS_COUNT);
+end:
+	return ret;
+}
+
+module_init(heci_init_module);
+
+
+/**
+ * heci_exit_module - Driver Exit Cleanup Routine
+ *
+ * heci_exit_module is called just before the driver is removed
+ * from memory.
+ *
+ * @return :
+ * none;
+ */
+
+static void __exit heci_exit_module(void)
+{
+	UNREGISTER_REBOOT_NOTIFIER(heci_reboot_notifier);
+	pci_unregister_driver(&heci_driver);
+	/* Now  unregister two cdevs. */
+	cdev_del(&iamt_legacy_cdev);
+	cdev_del(&heci_cdev);
+	unregister_chrdev_region(MKDEV(heci_major, 0), MINORS_COUNT);
+}
+
+module_exit(heci_exit_module);
+
+
+/**
+ * heci_probe - Device Initialization Routine
+ *
+ * @pdev: PCI device information struct
+ * @ent: entry in kcs_pci_tbl
+ *
+ * @return :
+ * 0 on success,
+ * negative on failure
+ */
+static int __devinit heci_probe(struct pci_dev *pdev,
+				const struct pci_device_id *ent)
+{
+	struct iamt_heci_device *device = NULL;
+	int i, err = 0;
+	if (heci_device) {
+		err = -EEXIST;
+		goto end;
+	}
+	/* enable pci device */
+	err = pci_enable_device(pdev);
+	if (err) {
+		ERR("Failed to enable pci device\n");
+		goto end;
+	}
+	/* set PCI host mastering  */
+	pci_set_master(pdev);
+	/* pci request regions for heci driver */
+	err = pci_request_regions(pdev, heci_driver_name);
+	if (err) {
+		ERR("Failed to get pci regions\n");
+		goto disable_device;
+	}
+	/* allocates and initializes the heci device structure */
+	device = init_heci_device(pdev);
+	if (!device) {
+		err = -ENOMEM;
+		goto release_regions;
+	}
+	/* mapping  IO device memory */
+	for (i = BAR_0; i <= BAR_5; i++) {
+		if (pci_resource_len(pdev, i) == 0) {
+			continue;
+		}
+		if (pci_resource_flags(pdev, i) & IORESOURCE_IO) {
+			ERR("heci has an IO ports.\n");
+			goto free_device;
+		} else if (pci_resource_flags(pdev, i) & IORESOURCE_MEM) {
+			if (device->mem_base) {
+				ERR("Too many mem addresses.\n");
+				goto free_device;
+			}
+			device->mem_base = pci_resource_start(pdev, i);
+			device->mem_length = pci_resource_len(pdev, i);
+		}
+	}
+	if (!device->mem_base) {
+		ERR("No address to use.\n");
+		err = -ENODEV;
+		goto free_device;
+	}
+	device->mem_addr = ioremap_nocache(device->mem_base, device->mem_length);
+	if (!device->mem_addr) {
+		ERR(" Remap IO device memory failure.\n");
+		err = -ENOMEM;
+		goto free_device;
+	}
+	/* request and enable interrupt   */
+	device->irq = pdev->irq;
+       err = request_irq(device->irq, heci_isr_interrupt, IRQF_SHARED,
+			heci_driver_name, device);
+	if (err) {
+		ERR("Request_irq failure. irq = %d \n", device->irq);
+		goto unmap_memory;
+	}
+
+	if (heci_hw_init(device)) {
+		ERR("init hw failure.\n");
+		err = -ENODEV;
+		goto release_irq;
+	}
+	init_timer(&device->wd_timer);
+	heci_initialize_clients(device);
+	if (device->heci_state != HECI_ENABLED) {
+		err = -ENODEV;
+		goto release_hw;
+	}
+	spin_lock_bh(&device->device_lock);
+	heci_device = pdev;
+	pci_set_drvdata(pdev, device);
+	spin_unlock_bh(&device->device_lock);
+	if (device->wd_timeout) {
+		mod_timer(&device->wd_timer, jiffies);
+	}
+#ifdef CONFIG_PM
+	g_sus_wd_timeout = 0;
+#endif
+	INFO("heci driver initialization successful.\n");
+	return ESUCCESS;
+
+release_hw:
+	/* disable interrupts */
+	device->host_hw_state = read_heci_register(device, H_CSR);
+	device->host_hw_state &= ~H_IE;
+	/* acknowledge interrupt and stop interupts */
+	write_heci_register(device, H_CSR, device->host_hw_state);
+
+	del_timer_sync(&device->wd_timer);
+
+
+	flush_scheduled_work();
+
+release_irq:
+	free_irq(pdev->irq, device);
+unmap_memory:
+	if (device->mem_addr)
+		iounmap(device->mem_addr);
+free_device:
+	kfree(device);
+release_regions:
+	pci_release_regions(pdev);
+disable_device:
+	pci_disable_device(pdev);
+end:
+	ERR("heci driver initialization failed.\n");
+	return err;
+}
+
+/**
+ * heci_remove - Device Removal Routine
+ * @pdev: PCI device information struct
+ *
+ * heci_remove is called by the PCI subsystem to alert the driver
+ * that it should release a PCI device.
+ *
+ * @return :
+ * none;
+ */
+static void __devexit heci_remove(struct pci_dev *pdev)
+{
+	struct iamt_heci_device *device = pci_get_drvdata(pdev);
+	int err = 0;
+
+	if (heci_device != pdev)
+		return;
+	del_timer_sync(&device->wd_timer);
+	if (device->wd_file_extension.state == HECI_FILE_CONNECTED
+	    && device->wd_timeout) {
+		spin_lock_bh(&device->device_lock);
+		device->wd_timeout = 0;
+		device->wd_due_counter = 0;
+		memcpy(device->wd_data, stop_wd_params, HECI_WD_PARAMS_SIZE);
+		device->stop = TRUE;
+		if (device->host_buffer_is_empty &&
+		    flow_control_credentials(device, &device->wd_file_extension)) {
+			device->host_buffer_is_empty = FALSE;
+
+			if (!heci_send_wd(device))
+				DBG("Send stop WD  failed\n");
+			else
+				flow_control_reduce(device, &device->wd_file_extension);
+			device->wd_pending = FALSE;
+
+		} else {
+			device->wd_pending = TRUE;
+		}
+		spin_unlock_bh(&device->device_lock);
+		device->wd_stoped = FALSE;
+
+		err =
+		    wait_event_interruptible_timeout(device->wait_stop_wd,
+						     (TRUE ==
+						      device->wd_stoped),
+						     10 * HZ);
+		if (!device->wd_stoped)
+			DBG("stop wd failed to complete.\n");
+		else
+			DBG("stop wd complete.\n");
+	}
+
+	heci_device = NULL;
+	if (device->legacy_file_extension.status == HECI_FILE_CONNECTED) {
+		device->legacy_file_extension.status = HECI_FILE_DISCONNECTING;
+		heci_disconnect_host_client(device,
+					    &device->legacy_file_extension);
+	}
+	if (device->wd_file_extension.status == HECI_FILE_CONNECTED) {
+		device->wd_file_extension.status = HECI_FILE_DISCONNECTING;
+		heci_disconnect_host_client(device,
+					    &device->wd_file_extension);
+	}
+	/* remove entry if already in list */
+	DBG("list del legacy and wd file list.\n");
+	heci_remove_client_from_file_list(device, device->wd_file_extension.
+					  host_client_id);
+	heci_remove_client_from_file_list(device, device->legacy_file_extension.
+					  host_client_id);
+	flush_scheduled_work();
+	/* disable interrupts */
+	device->host_hw_state &= ~H_IE;
+	/* acknowledge interrupt and stop interupts */
+	write_heci_register(device, H_CSR, device->host_hw_state);
+	free_irq(pdev->irq, device);
+	pci_set_drvdata(pdev, NULL);
+
+	if (device->mem_addr)
+		iounmap(device->mem_addr);
+	kfree(device);
+
+	pci_release_regions(pdev);
+	pci_disable_device(pdev);
+}
+/**
+ * heci_clear_list - remove all callbacks associated with file
+ * 		from heci_cb_list
+ * @file: file informtion struct
+ * @heci_cb_list: callbacks list
+ * heci_clear_list is called to clear resources associated with file
+ * when application calls close function or Ctrl-C was pressed
+ *
+ * @return :true if callback removed from the list, false otherwise
+ */
+static int heci_clear_list(struct iamt_heci_device *device, struct file *file, struct list_head *heci_cb_list) {
+	struct heci_cb_private *kernel_priv_cb_pos = NULL, *kernel_priv_cb_next = NULL;
+	struct file *file_temp = NULL;
+	int return_status = FALSE;
+
+	/* list all list member */
+	list_for_each_entry_safe(kernel_priv_cb_pos, kernel_priv_cb_next, heci_cb_list, cb_list){
+		file_temp = (struct file *)kernel_priv_cb_pos->file_object;
+		/* check if list member associated with a file */
+		if (file_temp == file) {
+			/* remove member from the list */
+			list_del(&kernel_priv_cb_pos->cb_list);
+			/* check if cb equal to current legacy cb */
+			if (device->legacy_current_cb == kernel_priv_cb_pos) {
+				device->legacy_current_cb = NULL;
+				/* send flow control to legacy client */
+				heci_send_flow_control(device, &device->legacy_file_extension);
+			}
+			/* free all allocated buffers */
+			kfree (kernel_priv_cb_pos->request_buffer.data);
+			kernel_priv_cb_pos->request_buffer.data = NULL;
+			kfree (kernel_priv_cb_pos->response_buffer.data);
+			kernel_priv_cb_pos->response_buffer.data = NULL;
+			kfree(kernel_priv_cb_pos);
+			return_status = TRUE;
+		}
+	}
+	return return_status;
+}
+
+/**
+ * heci_clear_lists - remove all callbacks associated with file
+ * @device: device informtion struct
+ * @file: file informtion struct
+ * heci_clear_lists is called to clear resources associated with file
+ * when application calls close function or Ctrl-C was pressed
+ *
+ * @return :true if callback removed from the list, false otherwise
+ */
+static int heci_clear_lists(struct iamt_heci_device *device, struct file *file)
+{
+	int return_status = FALSE;
+
+	/* remove callbacks associated with a file */
+	heci_clear_list(device, file, &device->pthi_cmd_list.heci_cb.cb_list);
+	if (heci_clear_list(device, file, &device->pthi_read_complete_list.heci_cb.cb_list))
+		return_status = TRUE;
+	heci_clear_list(device, file, &device->control_read_list.heci_cb.cb_list);
+	if (heci_clear_list(device, file, &device->control_write_list.heci_cb.cb_list))
+		return_status = TRUE;
+	if (heci_clear_list(device, file, &device->write_waiting_list.heci_cb.cb_list))
+		return_status = TRUE;
+	if (heci_clear_list(device, file, &device->write_list.heci_cb.cb_list))
+		return_status = TRUE;
+	/* check if legacy_current_cb not NULL */
+	if (device->legacy_current_cb && (!return_status)) {
+		/* check file and legacy current cb association */
+		if (device->legacy_current_cb->file_object == file) {
+			/* remove cb */
+			kfree (device->legacy_current_cb->request_buffer.data);
+			device->legacy_current_cb->request_buffer.data = NULL;
+			kfree (device->legacy_current_cb->response_buffer.data);
+			device->legacy_current_cb->response_buffer.data = NULL;
+			kfree(device->legacy_current_cb);
+			device->legacy_current_cb = NULL;
+			return_status = TRUE;
+		}
+	}
+	return return_status;
+}
+
+/**
+ * heci_open - the open function
+ */
+static int heci_open(struct inode *inode, struct file *file)
+{
+	struct heci_file_private *file_extension = NULL;
+	int if_num = MINOR(inode->i_rdev);
+	struct iamt_heci_device *device = NULL;
+	if (!heci_device)
+		return -ENODEV;
+	device = pci_get_drvdata(heci_device);
+	if (((if_num != LEGACY_MINOR_NUMBER)
+	     && (if_num != HECI_MINOR_NUMBER)) || (!device))
+		return -ENODEV;
+
+	if (if_num != LEGACY_MINOR_NUMBER) {
+		file_extension = alloc_priv(file);
+		if (!file_extension)
+			return -ENOMEM;
+	} else {
+		file->private_data =
+		    (void *) &device->legacy_file_extension;
+		return ESUCCESS;
+	}
+	spin_lock_bh(&device->device_lock);
+	if (device->heci_state != HECI_ENABLED) {
+		spin_unlock_bh(&device->device_lock);
+		kfree(file_extension);
+		file_extension = NULL;
+		return -ENODEV;
+	}
+	if (device->open_handle_count >= MAX_OPEN_HANDLE_COUNT) {
+		spin_unlock_bh(&device->device_lock);
+		kfree(file_extension);
+		file_extension = NULL;
+		return -ENFILE;
+	};
+	device->open_handle_count++;
+	list_add_tail(&file_extension->link, &device->file_list);
+	while ((device->heci_host_clients[device->current_host_client_id / 8]
+		& (1 << (device->current_host_client_id % 8))) != 0) {
+		device->current_host_client_id++; /* allow overflow */
+		DBG("current_host_client_id = %d\n", device->current_host_client_id);
+		DBG("device->open_handle_count = %lu\n", device->open_handle_count);
+	}
+	DBG("current_host_client_id = %d\n", device->current_host_client_id);
+	file_extension->host_client_id = device->current_host_client_id;
+	device->heci_host_clients[file_extension->host_client_id / 8] |=
+		    (1 << (file_extension->host_client_id % 8));
+	spin_unlock_bh(&device->device_lock);
+	spin_lock(&file_extension->file_lock);
+	file_extension->state = HECI_FILE_INITIALIZING;
+	file_extension->sm_state = 0;
+
+	file->private_data = file_extension;
+	spin_unlock(&file_extension->file_lock);
+
+	return ESUCCESS;
+}
+
+/**
+ * heci_release - the release function
+ */
+static int heci_release(struct inode *inode, struct file *file)
+{
+	int return_status = ESUCCESS;
+	int if_num = MINOR(inode->i_rdev);
+	struct heci_file_private *file_extension = file->private_data;
+	struct heci_cb_private *kernel_priv_cb = NULL;
+	struct iamt_heci_device *device = NULL;
+
+	if (!heci_device)
+		return -ENODEV;
+
+	device = pci_get_drvdata(heci_device);
+	if (((if_num != LEGACY_MINOR_NUMBER)
+	     && (if_num != HECI_MINOR_NUMBER)) || (!device)
+	    || (!file_extension))
+		return -ENODEV;
+	if (file_extension != &device->legacy_file_extension) {
+
+		spin_lock(&file_extension->file_lock);
+		if (file_extension->state == HECI_FILE_CONNECTED) {
+			file_extension->state = HECI_FILE_DISCONNECTING;
+			spin_unlock(&file_extension->file_lock);
+			DBG("disconnecting  client host client = %d, ME client = %d\n",
+					file_extension->host_client_id,
+					file_extension->me_client_id);
+			return_status =
+			    heci_disconnect_host_client(device,
+							file_extension);
+			spin_lock(&file_extension->file_lock);
+		}
+		spin_lock_bh(&device->device_lock);
+		heci_flush_queues(device, file_extension);
+                DBG("remove client host client = %d, ME client = %d\n",
+					file_extension->host_client_id,
+					file_extension->me_client_id);
+		device->heci_host_clients[file_extension->host_client_id / 8] &= ~(1 << (file_extension->host_client_id % 8));
+		device->open_handle_count--;
+		heci_remove_client_from_file_list(device, file_extension->host_client_id);
+		spin_unlock_bh(&device->device_lock);
+
+		/* free read cb */
+		if (file_extension->read_cb != NULL) {
+			spin_unlock(&file_extension->file_lock);
+			kernel_priv_cb = file_extension->read_cb;
+			kfree(kernel_priv_cb->response_buffer.data);
+			kernel_priv_cb->response_buffer.data = NULL;
+			kfree(kernel_priv_cb);
+			kernel_priv_cb = NULL;
+
+			file_extension->read_cb = NULL;
+			spin_lock(&file_extension->file_lock);
+		}
+		spin_unlock(&file_extension->file_lock);
+		kfree(file_extension);
+		file->private_data = NULL;
+	} else {
+		spin_lock_bh(&device->device_lock);
+		if (if_num != LEGACY_MINOR_NUMBER) {
+			device->open_handle_count--;
+		}
+		if (device->legacy_file_object == file
+		    && device->legacy_state != HECI_LEGACY_IDLE) {
+
+			DBG("pthi canceled legacy state %d\n",
+			    device->legacy_state);
+			device->legacy_canceled = TRUE;
+			if (device->legacy_state == HECI_LEGACY_READ_COMPLETE) {
+				DBG("run next pthi legacy cb\n");
+				run_next_legacy_cmd(device);
+			}
+		}
+
+		if (heci_clear_lists(device, file)) {
+		    device->legacy_state = HECI_LEGACY_IDLE;
+		}
+		spin_unlock_bh(&device->device_lock);
+	}
+	return return_status;
+}
+
+
+static struct heci_cb_private *find_read_list_entry(struct iamt_heci_device* device,
+													struct heci_file_private *file_extension)
+{
+	struct heci_cb_private *kernel_priv_cb_pos = NULL, *kernel_priv_cb_next = NULL;
+	struct heci_file_private *file_extension_list_temp = NULL;
+
+	if (device->read_list.status == ESUCCESS
+			&& !list_empty(&device->read_list.heci_cb.cb_list)) {
+		DBG("remove read_list CB \n");
+		list_for_each_entry_safe(kernel_priv_cb_pos, kernel_priv_cb_next, &device->read_list.heci_cb.cb_list, cb_list){
+			file_extension_list_temp =
+				(struct heci_file_private *)
+				kernel_priv_cb_pos->file_private;
+			if (file_extension_list_temp) {
+				if ((file_extension->host_client_id == file_extension_list_temp->host_client_id)
+						&& (file_extension->me_client_id == file_extension_list_temp->me_client_id))
+					return kernel_priv_cb_pos;
+			}
+		}
+	}
+	return NULL;
+}
+/**
+ * heci_read - the read client message function.
+ */
+static ssize_t heci_read(struct file *file, char __user * ubuf,
+			 size_t length, loff_t * offset)
+{
+	int i;
+	int return_status = ESUCCESS, err = ESUCCESS;
+	int if_num = MINOR((file->f_dentry->d_inode->i_rdev));
+	struct heci_file_private *file_extension = file->private_data;
+	struct heci_cb_private *kernel_priv_cb_pos = NULL;
+	struct heci_cb_private *kernel_priv_cb = NULL;
+	struct iamt_heci_device *device = NULL;
+
+	if (!heci_device)
+		return -ENODEV;
+
+	device = pci_get_drvdata(heci_device);
+	if ((if_num != HECI_MINOR_NUMBER) || (!device) || (!file_extension))
+		return -ENODEV;
+
+	spin_lock_bh(&device->device_lock);
+	if (device->heci_state != HECI_ENABLED) {
+		spin_unlock_bh(&device->device_lock);
+		return -ENODEV;
+	}
+	spin_unlock_bh(&device->device_lock);
+	if (!file_extension)
+		return -ENODEV;
+
+	spin_lock(&file_extension->file_lock);
+	if((file_extension->sm_state & HECI_WD_STATE_INDEPENDENCE_MSG_SENT) == 0) {
+			spin_unlock(&file_extension->file_lock);
+			/* Do not allow to read watchdog client */
+ 			for (i = 0; i < device->num_heci_me_clients; i++) {
+				if (0 == memcmp(&heci_wd_guid, &device->me_clients[i].properteis.protocol_name, sizeof(struct guid))) {
+					if (file_extension->me_client_id == device->me_clients[i].client_id)
+						return -EBADF;
+				}
+			}
+	} else {
+		file_extension->sm_state &= ~HECI_WD_STATE_INDEPENDENCE_MSG_SENT;
+		spin_unlock(&file_extension->file_lock);
+	}
+	if (file_extension == &device->legacy_file_extension) {
+		return_status = pthi_read(device, if_num, file, ubuf, length, offset);
+		goto out;
+	}
+
+	if (file_extension->read_cb && file_extension->read_cb->information > *offset) {
+		kernel_priv_cb = file_extension->read_cb;
+		goto copy_buffer;
+	}
+	else if (file_extension->read_cb && file_extension->read_cb->information > 0 &&
+				file_extension->read_cb->information <= *offset) {
+		kernel_priv_cb = file_extension->read_cb;
+		return_status = 0;
+	    goto free;
+	}
+	else if ((!file_extension->read_cb || file_extension->read_cb->information == 0) &&
+			 *offset > 0) {
+		*offset = 0;	/*Offset needs to be cleaned for contingous reads*/
+		return_status = 0;
+	    goto out;
+	}
+
+	spin_lock(&file_extension->read_io_lock);
+	err = heci_start_read(device, if_num, file_extension);
+	if (err != ESUCCESS && err != -EBUSY) {
+		DBG("heci start read failure with status = %d\n", err);
+		spin_unlock(&file_extension->read_io_lock);
+		return_status = err;
+		goto out;
+	}
+	if (HECI_READ_COMPLETE != file_extension->reading_state && !waitqueue_active (&file_extension->rx_wait)) {
+		if (file->f_flags & O_NONBLOCK) {
+			return_status = -EAGAIN;
+			spin_unlock(&file_extension->read_io_lock);
+			goto out;
+		}
+		spin_unlock(&file_extension->read_io_lock);
+
+		if (wait_event_interruptible(file_extension->rx_wait,
+			(HECI_READ_COMPLETE == file_extension->reading_state ||
+			HECI_FILE_INITIALIZING == file_extension->state ||
+			HECI_FILE_DISCONNECTED == file_extension->state ||
+			HECI_FILE_DISCONNECTING == file_extension->state))) {
+			if (signal_pending (current)) {
+				return_status = -EINTR;
+				goto out;
+			}
+			return -ERESTARTSYS;
+		}
+
+		if (HECI_FILE_INITIALIZING == file_extension->state ||
+			HECI_FILE_DISCONNECTED == file_extension->state ||
+			HECI_FILE_DISCONNECTING == file_extension->state) {
+			return_status = -EBUSY;
+			goto out;
+		}
+		spin_lock(&file_extension->read_io_lock);
+	}
+
+	kernel_priv_cb = file_extension->read_cb;
+
+	if (!kernel_priv_cb) {
+		spin_unlock(&file_extension->read_io_lock);
+		return -ENODEV;
+	}
+	if (file_extension->reading_state != HECI_READ_COMPLETE) {
+		spin_unlock(&file_extension->read_io_lock);
+		return ESUCCESS;
+	}
+	spin_unlock(&file_extension->read_io_lock);
+	/* now copy the data to user space */
+copy_buffer:
+	DBG("kernel_priv_cb->response_buffer size - %d\n", kernel_priv_cb->response_buffer.size);
+	DBG("kernel_priv_cb->information - %lu\n", kernel_priv_cb->information);
+	if (length == 0 || ubuf == NULL || *offset > kernel_priv_cb->information) {
+		return_status = -EMSGSIZE;
+		goto free;
+	}
+
+	/* length is being turncated to PAGE_SIZE, however, information size may be longer */
+	length = (length < (kernel_priv_cb->information - *offset) ?
+					length : (kernel_priv_cb->information - *offset));
+
+	if (copy_to_user(ubuf, kernel_priv_cb->response_buffer.data + *offset, length)) {
+		return_status = -EFAULT;
+		goto free;
+	}
+	else {
+		return_status = length;
+		*offset += length;
+		if ((unsigned long)*offset < kernel_priv_cb->information) {
+			goto out;
+		}
+	}
+free:
+	spin_lock_bh(&device->device_lock);
+    kernel_priv_cb_pos = find_read_list_entry(device, file_extension);
+	/* Remove entry from read list */
+	if (kernel_priv_cb_pos != NULL)
+		list_del(&kernel_priv_cb_pos->cb_list);
+	spin_unlock_bh(&device->device_lock);
+	kfree(kernel_priv_cb->response_buffer.data);
+	kernel_priv_cb->response_buffer.data = NULL;
+	kfree(kernel_priv_cb);
+	kernel_priv_cb = NULL;
+	spin_lock(&file_extension->read_io_lock);
+	file_extension->reading_state = HECI_IDLE;
+	file_extension->read_cb = NULL;
+	file_extension->read_pending = FALSE;
+	spin_unlock(&file_extension->read_io_lock);
+out:	DBG("end heci read return_status= %d\n", return_status);
+	return return_status;
+}
+
+/**
+ * heci_write - the write function.
+ */
+static ssize_t heci_write(struct file *file, const char __user * ubuf,
+			  size_t length, loff_t * offset)
+{
+	int return_status = ESUCCESS;
+	__u8 i;
+	int if_num = MINOR((file->f_dentry->d_inode->i_rdev));
+	struct heci_file_private *file_extension = file->private_data;
+	struct heci_cb_private *priv_write_cb = NULL;
+	struct heci_message_header heci_header;
+	struct iamt_heci_device *device = NULL;
+	unsigned long currtime = get_seconds();
+
+	if (!heci_device)
+		return -ENODEV;
+	device = pci_get_drvdata(heci_device);
+
+	if ((if_num != HECI_MINOR_NUMBER) || (!device) || (!file_extension))
+		return -ENODEV;
+	spin_lock_bh(&device->device_lock);
+
+	if (device->heci_state != HECI_ENABLED) {
+		spin_unlock_bh(&device->device_lock);
+		return -ENODEV;
+	}
+	if (file_extension == &device->legacy_file_extension) {
+		priv_write_cb = find_pthi_read_list_entry(device, file, file_extension);
+		if ((priv_write_cb && currtime - priv_write_cb->read_time > LEGACY_READ_TIMER) ||
+			(priv_write_cb && file_extension->reading_state == HECI_READ_COMPLETE)) {
+				*offset = 0;
+				list_del(&priv_write_cb->cb_list);
+				kfree(priv_write_cb->request_buffer.data);
+				kfree(priv_write_cb->response_buffer.data);
+				kfree(priv_write_cb);
+		}
+	}
+
+	//free entry used in read 
+	if (file_extension->reading_state == HECI_READ_COMPLETE)
+	{
+		*offset = 0;
+		priv_write_cb = find_read_list_entry(device, file_extension);
+		if ( priv_write_cb != NULL) {
+			list_del(&priv_write_cb->cb_list);
+			kfree(priv_write_cb->response_buffer.data);
+			priv_write_cb->response_buffer.data = NULL;
+			kfree(priv_write_cb);
+			priv_write_cb = NULL;
+			spin_lock(&file_extension->read_io_lock);
+			file_extension->reading_state = HECI_IDLE;
+			file_extension->read_cb = NULL;
+			file_extension->read_pending = FALSE;
+			spin_unlock(&file_extension->read_io_lock);
+		}
+	}
+	else if (file_extension->reading_state == HECI_IDLE &&  
+		file_extension->read_pending == FALSE){
+		*offset = 0;
+	}
+
+	spin_unlock_bh(&device->device_lock);
+
+	priv_write_cb = kmalloc(sizeof(struct heci_cb_private), GFP_KERNEL);
+	if (!priv_write_cb)
+		return -ENOMEM;
+	spin_lock(&file_extension->file_lock);
+	priv_write_cb->request_buffer.data = NULL;
+	priv_write_cb->response_buffer.data = NULL;
+	priv_write_cb->file_object = file;
+	priv_write_cb->file_private = file_extension;
+	spin_unlock(&file_extension->file_lock);
+	priv_write_cb->request_buffer.data = kmalloc(length, GFP_KERNEL);
+	if (!priv_write_cb->request_buffer.data) {
+		kfree(priv_write_cb);
+		return -ENOMEM;
+	}
+	DBG("length =%d\n", (int) length);
+
+	if (copy_from_user(priv_write_cb->request_buffer.data,
+		ubuf, length)) {
+		return_status = -EFAULT;
+		goto fail;
+	}
+	
+	spin_lock(&file_extension->file_lock);
+	file_extension->sm_state = 0;
+	if (length == 4 &&
+		((memcmp(heci_wd_state_independence_msg[0], ubuf, 4) == 0) ||
+		 (memcmp(heci_wd_state_independence_msg[1], ubuf, 4) == 0))) {
+		file_extension->sm_state |= HECI_WD_STATE_INDEPENDENCE_MSG_SENT;
+   }
+	spin_unlock(&file_extension->file_lock);
+
+	INIT_LIST_HEAD(&priv_write_cb->cb_list);
+	if (file_extension == &device->legacy_file_extension) {
+		priv_write_cb->response_buffer.data =
+		    kmalloc(LEGACY_MTU, GFP_KERNEL);
+		if (!priv_write_cb->response_buffer.data) {
+			return_status = -ENOMEM;
+			goto fail;
+		}
+		spin_lock_bh(&device->device_lock);
+              if (device->heci_state != HECI_ENABLED) {
+		    spin_unlock_bh(&device->device_lock);
+		    return_status = -ENODEV;
+		    goto fail;
+	       }
+		for (i = 0; i < device->num_heci_me_clients; i++) {
+			if (device->me_clients[i].client_id ==
+			    device->legacy_file_extension.me_client_id)
+				break;
+		}
+
+		BUG_ON(device->me_clients[i].client_id !=
+		       file_extension->me_client_id);
+		if ((i == device->num_heci_me_clients)
+		    || (device->me_clients[i].client_id != device->legacy_file_extension.me_client_id)) {
+			spin_unlock_bh(&device->device_lock);
+			return_status = -ENODEV;
+			goto fail;
+		} else if (length > device->me_clients[i].properteis.max_message_length || length <= 0) {
+			spin_unlock_bh(&device->device_lock);
+			return_status = -EMSGSIZE;
+			goto fail;
+		}
+
+
+		priv_write_cb->response_buffer.size = LEGACY_MTU;
+		priv_write_cb->major_file_operations = HECI_IOCTL;
+		priv_write_cb->information = 0;
+		priv_write_cb->request_buffer.size = length;
+		if (device->legacy_file_extension.state != HECI_FILE_CONNECTED) {
+			spin_unlock_bh(&device->device_lock);
+			return_status = -ENODEV;
+			goto fail;
+		}
+
+		if (!list_empty(&device->pthi_cmd_list.heci_cb.cb_list)
+		    || device->legacy_state != HECI_LEGACY_IDLE) {
+			DBG("pthi_state = %d\n", (int) device->legacy_state);
+			DBG("add PTHI cb to pthi cmd waiting list\n");
+			list_add_tail(&priv_write_cb->cb_list,
+				      &device->pthi_cmd_list.heci_cb.
+				      cb_list);
+			return_status = length;
+		} else {
+			DBG("call pthi write");
+			return_status = pthi_write(device, priv_write_cb);
+
+			if (ESUCCESS != return_status) {
+				DBG("pthi write failed with status = %d\n",
+				    return_status);
+				spin_unlock_bh(&device->device_lock);
+				goto fail;
+			};
+			return_status = length;
+		}
+		spin_unlock_bh(&device->device_lock);
+		return return_status;
+	}
+
+	priv_write_cb->major_file_operations = HECI_WRITE;
+	/* make sure information is zero before we start */
+
+	priv_write_cb->information = 0;
+	priv_write_cb->request_buffer.size = length;
+
+	spin_lock(&file_extension->write_io_lock);
+	DBG("host client = %d, ME client = %d\n",
+	    file_extension->host_client_id, file_extension->me_client_id);
+	if (file_extension->state != HECI_FILE_CONNECTED) {
+		return_status = -ENODEV;
+		DBG("host client = %d,  is not connected to ME client = %d",
+				file_extension->host_client_id,
+				file_extension->me_client_id);
+
+		goto unlock;
+	}
+	for (i = 0; i < device->num_heci_me_clients; i++) {
+		if (device->me_clients[i].client_id ==
+		    file_extension->me_client_id)
+			break;
+	}
+	BUG_ON(device->me_clients[i].client_id != file_extension->me_client_id);
+	if (i == device->num_heci_me_clients) {
+		return_status = -ENODEV;
+		goto unlock;
+	}
+	if (length > device->me_clients[i].properteis.max_message_length
+			|| length <= 0) {
+		return_status = -EINVAL;
+		goto unlock;
+	}
+	priv_write_cb->file_private = file_extension;
+
+	spin_lock_bh(&device->device_lock);
+	if (flow_control_credentials(device, file_extension) &&
+		device->host_buffer_is_empty) {
+		spin_unlock_bh(&device->device_lock);
+		device->host_buffer_is_empty = FALSE;
+		if (length > ((((device->host_hw_state & H_CBD) >> 24) * sizeof(__u32)) - sizeof(struct heci_message_header))) {
+			heci_header.length = (((device->host_hw_state & H_CBD) >> 24)
+					* sizeof(__u32)) - sizeof(struct heci_message_header);
+			heci_header.message_complete = 0;
+		} else {
+			heci_header.length = length;
+			heci_header.message_complete = 1;
+		}
+		heci_header.host_address = file_extension->host_client_id;
+		heci_header.me_address = file_extension->me_client_id;
+		heci_header.reserved = 0;
+		DBG("call heci_write_message header=%08x.\n",
+		    *((__u32 *) & heci_header));
+		spin_unlock(&file_extension->write_io_lock);
+		/*  protect heci low level write */
+		spin_lock_bh(&device->device_lock);
+		if (!heci_write_message(device, &heci_header, (unsigned char *) (priv_write_cb->request_buffer.data),
+					heci_header.length)) {
+			spin_unlock_bh(&device->device_lock);
+			kfree(priv_write_cb->request_buffer.data);
+			priv_write_cb->request_buffer.data = NULL;
+			kfree(priv_write_cb);
+			return_status = -ENODEV;
+			priv_write_cb->information = 0;
+			return return_status;
+		}
+		file_extension->writing_state = HECI_WRITING;
+		priv_write_cb->information = heci_header.length;
+		if (heci_header.message_complete) {
+			flow_control_reduce(device, file_extension);
+			list_add_tail(&priv_write_cb->cb_list,
+				      &device->write_waiting_list.heci_cb.
+				      cb_list);
+		} else {
+			list_add_tail(&priv_write_cb->cb_list,
+				      &device->write_list.heci_cb.cb_list);
+		}
+		spin_unlock_bh(&device->device_lock);
+
+	} else {
+
+		spin_unlock_bh(&device->device_lock);
+		priv_write_cb->information = 0;
+		file_extension->writing_state = HECI_WRITING;
+		spin_unlock(&file_extension->write_io_lock);
+		list_add_tail(&priv_write_cb->cb_list,
+			      &device->write_list.heci_cb.cb_list);
+	}
+	return length;
+
+unlock:
+	spin_unlock(&file_extension->write_io_lock);
+fail:
+	kfree(priv_write_cb->request_buffer.data);
+	priv_write_cb->request_buffer.data = NULL;
+	kfree(priv_write_cb->response_buffer.data);
+	priv_write_cb->response_buffer.data = NULL;
+	kfree(priv_write_cb);
+	return return_status;
+
+}
+
+/**
+ * heci_ioctl - the IOCTL function
+ */
+static int heci_ioctl(struct inode *inode, struct file *file,
+		      unsigned int cmd, unsigned long data)
+{
+
+	int return_status = ESUCCESS;
+	int if_num = MINOR(inode->i_rdev);
+	struct heci_file_private *file_extension = file->private_data;
+	struct heci_message_data *u_msg = (struct heci_message_data *) data;	/* in user space */
+	struct heci_message_data k_msg;	/* all in kernel on the stack */
+	struct iamt_heci_device *device = NULL;
+
+
+       if (!capable(CAP_SYS_ADMIN))
+                       return -EPERM;
+	if (!heci_device)
+		return -ENODEV;
+	device = pci_get_drvdata(heci_device);
+	if (((if_num != LEGACY_MINOR_NUMBER)
+	     && (if_num != HECI_MINOR_NUMBER)) || (!device)
+	    || (!file_extension))
+		return -ENODEV;
+	if (device->heci_state != HECI_ENABLED)
+		return -ENODEV;
+	/* first copy from user all data needed */
+	if (copy_from_user(&k_msg, u_msg, sizeof(k_msg))) {
+		DBG("first copy from user all data needed filed\n");
+		return -EFAULT;
+	}
+	DBG("user message size is %d\n", k_msg.size);
+
+	switch (cmd) {
+	case IOCTL_HECI_GET_VERSION:
+		DBG(": IOCTL_HECI_GET_VERSION\n");
+		return_status =
+		    heci_ioctl_get_version(device, if_num, u_msg, k_msg,
+					   file_extension);
+		break;
+	case IOCTL_HECI_CONNECT_CLIENT:
+		DBG(": IOCTL_HECI_CONNECT_CLIENT.\n");
+		return_status =
+		    heci_ioctl_connect_client(device, if_num, u_msg, k_msg,
+					      file);
+		break;
+	case IOCTL_HECI_WD:
+		DBG(": IOCTL_HECI_WD.\n");
+		return_status =
+		    heci_ioctl_wd(device, if_num, k_msg, file_extension);
+		break;
+	case IOCTL_HECI_BYPASS_WD:
+		DBG(":IOCTL_HECI_BYPASS_WD.\n");
+		return_status =
+		    heci_ioctl_bypass_wd(device,if_num,k_msg,file_extension);
+		break;
+	case IAMT_KCS_SEND_MESSAGE_COMMAND:
+		DBG(": IAMT_KCS_SEND_MESSAGE_COMMAND.\n");
+		return_status =
+		    legacy_ioctl_send_message(device, if_num, k_msg, file);
+		break;
+	case IAMT_KCS_RECEIVE_MESSAGE_COMMAND:
+		DBG(": IAMT_KCS_RECEIVE_MESSAGE_COMMAND.\n");
+		return_status =
+		    legacy_ioctl_receive_message(device, if_num, u_msg,
+						 k_msg, file);
+		break;
+
+	default:
+		return_status = -EINVAL;
+		break;
+	}
+	return return_status;
+}
+
+/**
+ * heci_legacy_poll - the poll function
+ */
+static unsigned int heci_legacy_poll(struct file *file, poll_table * wait)
+{
+	int if_num = MINOR((file->f_dentry->d_inode->i_rdev));
+	unsigned int mask = 0;
+	struct iamt_heci_device *device = NULL;
+	struct heci_file_private *file_extension = file->private_data;
+
+
+	if (!heci_device || !file_extension)
+		return mask;
+
+	device = pci_get_drvdata(heci_device);
+
+	if ((if_num != LEGACY_MINOR_NUMBER) || (!device))
+		return mask;
+
+	spin_lock_bh(&device->device_lock);
+	if (device->heci_state != HECI_ENABLED){
+		spin_unlock_bh(&device->device_lock);
+		return mask;
+	}
+	spin_unlock_bh(&device->device_lock);
+	if (file_extension == &device->legacy_file_extension) {
+
+		poll_wait(file, &device->legacy_file_extension.wait, wait);
+		spin_lock(&device->legacy_file_extension.file_lock);
+		if (device->legacy_state == HECI_LEGACY_READ_COMPLETE
+		    && device->legacy_file_object == file) {
+			mask |= (POLLIN | POLLRDNORM);
+			spin_lock_bh(&device->device_lock);
+			DBG("run next pthi legacy cb\n");
+			run_next_legacy_cmd(device);
+			spin_unlock_bh(&device->device_lock);
+		}
+		spin_unlock(&device->legacy_file_extension.file_lock);
+	}
+	return mask;
+}
+
+/**
+ * heci_poll - the poll function
+ */
+static unsigned int heci_poll(struct file *file, poll_table * wait)
+{
+	int if_num = MINOR((file->f_dentry->d_inode->i_rdev));
+	unsigned int mask = 0;
+	struct heci_file_private *file_extension = file->private_data;
+	struct iamt_heci_device *device = NULL;
+
+	if (!heci_device)
+		return mask;
+
+
+	device = pci_get_drvdata(heci_device);
+
+	if ((if_num != HECI_MINOR_NUMBER) || (!device)
+	    || (!file_extension))
+		return mask;
+
+	spin_lock_bh(&device->device_lock);
+	if (device->heci_state != HECI_ENABLED){
+		spin_unlock_bh(&device->device_lock);
+		return mask;
+
+	}
+	spin_unlock_bh(&device->device_lock);
+	if (file_extension == &device->legacy_file_extension) {
+
+
+		poll_wait(file, &device->legacy_file_extension.wait, wait);
+		spin_lock(&device->legacy_file_extension.file_lock);
+		if (device->legacy_state == HECI_LEGACY_READ_COMPLETE
+		    && device->legacy_file_object == file) {
+			mask |= (POLLIN | POLLRDNORM);
+			spin_lock_bh(&device->device_lock);
+			DBG("run next pthi cb");
+			run_next_legacy_cmd(device);
+			spin_unlock_bh(&device->device_lock);
+		}
+		spin_unlock(&device->legacy_file_extension.file_lock);
+
+	} else{
+		poll_wait(file, &file_extension->tx_wait, wait);
+		spin_lock(&file_extension->write_io_lock);
+		if (HECI_WRITE_COMPLETE == file_extension->writing_state)
+			mask |= (POLLIN | POLLRDNORM);
+		spin_unlock(&file_extension->write_io_lock);
+	}
+	return mask;
+}
+
+#ifdef CONFIG_PM
+static int heci_suspend(struct pci_dev* pdev, pm_message_t state)
+{
+	struct iamt_heci_device *device = pci_get_drvdata(pdev);
+	int err = 0;
+
+	//Stop watchdog if exists
+	del_timer_sync(&device->wd_timer);
+	if (device->wd_file_extension.state == HECI_FILE_CONNECTED
+		&& device->wd_timeout) {
+			spin_lock_bh(&device->device_lock);
+			g_sus_wd_timeout = device->wd_timeout;
+			device->wd_timeout = 0;
+			device->wd_due_counter = 0;
+			memcpy(device->wd_data, stop_wd_params, HECI_WD_PARAMS_SIZE);
+			device->stop = TRUE;
+			if (device->host_buffer_is_empty &&
+				flow_control_credentials(device, &device->wd_file_extension)) {
+					device->host_buffer_is_empty = FALSE;
+			
+					if (!heci_send_wd(device))
+						DBG("Send stop WD  failed\n");
+			        else
+						flow_control_reduce(device, &device->wd_file_extension);
+					device->wd_pending = FALSE;
+			} else {
+				device->wd_pending = TRUE;
+			}
+			spin_unlock_bh(&device->device_lock);
+			device->wd_stoped = FALSE;
+
+			err =
+				wait_event_interruptible_timeout(device->wait_stop_wd,
+										(TRUE == device->wd_stoped), 10 * HZ);
+			if (!device->wd_stoped)
+				DBG("stop wd failed to complete.\n");
+			else {
+				DBG("stop wd complete %d.\n", err);
+				err = 0;
+			}
+	}
+	//Set new heci state
+	spin_lock_bh(&device->device_lock);
+	if (device->heci_state == HECI_ENABLED || 
+			device->heci_state == HECI_RECOVERING_FROM_RESET) {
+		device->heci_state = HECI_POWER_DOWN;
+		heci_reset(device, FALSE);
+	}
+	spin_unlock_bh(&device->device_lock);
+
+	pci_save_state(pdev);
+
+
+	pci_disable_device(pdev);
+	free_irq(pdev->irq, device);
+
+	pci_set_power_state(pdev, PCI_D3hot);
+
+	return err;
+}
+
+static int heci_resume(struct pci_dev* pdev)
+{
+	struct iamt_heci_device *device = NULL;
+	int err = 0;
+
+	pci_set_power_state(pdev, PCI_D0);
+	pci_restore_state(pdev);
+
+	device = pci_get_drvdata(pdev);
+	if (!device) {
+		return -ENODEV;
+	}
+
+	/* request and enable interrupt   */
+	device->irq = pdev->irq;
+	err = request_irq(device->irq, heci_isr_interrupt, IRQF_SHARED,
+			heci_driver_name, device);
+	if (err) {
+		ERR("Request_irq failure. irq = %d \n", device->irq);
+		return err;
+	}
+
+	spin_lock_bh(&device->device_lock);
+	device->heci_state = HECI_POWER_UP;
+	heci_reset(device, TRUE);	
+	spin_unlock_bh(&device->device_lock);
+
+	//Start watchdog if stopped in suspend
+	if (g_sus_wd_timeout != 0) {
+		device->wd_timeout = g_sus_wd_timeout;
+
+		memcpy(device->wd_data, start_wd_params, HECI_WD_PARAMS_SIZE);
+		memcpy(device->wd_data + HECI_WD_PARAMS_SIZE, &device->wd_timeout, 
+				sizeof(__u16));
+		device->wd_due_counter = 1;
+
+		if (device->wd_timeout)
+			mod_timer(&device->wd_timer, jiffies);
+		g_sus_wd_timeout = 0;
+	}
+	return err;
+}
+#endif
+MODULE_AUTHOR("Intel Corporation"); /* FIXME: Add email address here */
+MODULE_DESCRIPTION("Intel(R) AMT Management Interface");
+MODULE_LICENSE("Dual BSD/GPL");
+MODULE_VERSION(DRIVER_VERSION);
diff -Nurp linux-2.6.37/3rdparty/heci/interrupt.c linux-2.6.37.3rdparty/3rdparty/heci/interrupt.c
--- linux-2.6.37/3rdparty/heci/interrupt.c	1970-01-01 02:00:00.000000000 +0200
+++ linux-2.6.37.3rdparty/3rdparty/heci/interrupt.c	2008-01-24 14:04:22.000000000 +0200
@@ -0,0 +1,1413 @@
+/*
+ * Part of Intel(R) Manageability Engine Interface Linux driver
+ *
+ * Copyright (c) 2006-2007 Intel Corp.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions, and the following disclaimer,
+ *    without modification.
+ * 2. Redistributions in binary form must reproduce at minimum a disclaimer
+ *    substantially similar to the "NO WARRANTY" disclaimer below
+ *    ("Disclaimer") and any redistribution must be conditioned upon
+ *    including a substantially similar Disclaimer requirement for further
+ *    binary redistribution.
+ * 3. Neither the names of the above-listed copyright holders nor the names
+ *    of any contributors may be used to endorse or promote products derived
+ *    from this software without specific prior written permission.
+ *
+ * Alternatively, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") version 2 as published by the Free
+ * Software Foundation.
+ *
+ * NO WARRANTY
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGES.
+ *
+ */
+
+#include <asm/uaccess.h>
+#include <linux/kthread.h>
+#include "kcompat.h"
+#include "heci.h"
+#include "heci_interface.h"
+
+/**
+ *  interrupt function prototypes
+ */
+
+void heci_bh_handler(struct work_struct *work);
+int heci_bh_read_handler(struct io_heci_list *complete_list,
+		struct iamt_heci_device * device_object,
+		__s32 * slots);
+int heci_bh_write_handler(struct io_heci_list *complete_list,
+		struct iamt_heci_device * device_object,
+		__s32 * slots);
+void heci_bh_read_bus_message(struct iamt_heci_device * device_object,
+		struct heci_message_header * heci_header);
+int heci_bh_read_pthi_message(struct io_heci_list *complete_list,
+		struct iamt_heci_device * device_object,
+		struct heci_message_header * heci_header);
+int heci_bh_read_client_message(struct io_heci_list *complete_list,
+		struct iamt_heci_device * device_object,
+		struct heci_message_header * heci_header);
+void heci_client_connect_response(struct iamt_heci_device * device_object,
+		struct hbm_client_connect_response *
+		connect_res);
+void heci_client_disconnect_response(struct iamt_heci_device * device_object,
+		struct hbm_client_connect_response *
+		disconnect_res);
+void heci_client_flow_control_response(struct iamt_heci_device * device_object,
+		struct hbm_flow_control * flow_control);
+void heci_client_disconnect_request(struct iamt_heci_device * device_object,
+		struct hbm_client_disconnect_request *
+		disconnect_req);
+
+
+/**
+ * heci_isr_interrupt - The ISR of the HECI device
+ * @irq: The irq number
+ * @dev_id: pointer to the device structure
+ * @regs: the register values
+ *
+ * @return :
+ * irqreturn_t
+ */
+irqreturn_t heci_isr_interrupt(int irq, void *dev_id)
+{
+	int err;
+	struct iamt_heci_device *device = (struct iamt_heci_device *) dev_id;
+	device->host_hw_state = read_heci_register(device, H_CSR);
+
+	if ((device->host_hw_state & H_IS) != H_IS)
+		return IRQ_NONE;
+
+	/* disable interrupts */
+	device->host_hw_state &= ~H_IE;
+	/* acknowledge interrupt and stop interupts */
+	write_heci_register(device, H_CSR, device->host_hw_state);
+	/**
+	 * Our device interrupted, schedule work the heci_bh_handler
+	 * to handle the interrupt processing. This needs to be a
+	 * workqueue item since the handler can sleep.
+	 */
+	PREPARE_WORK(&device->work, heci_bh_handler);
+	DBG("schedule work the heci_bh_handler \n");
+	err = schedule_work(&device->work);
+	if (!err)
+		ERR("schedule work the heci_bh_handler failed error=%x\n",
+				err);
+	return IRQ_HANDLED;
+}
+
+/**
+ * heci_bh_handler - function called after ISR to handle the interrupt processing.
+ * @data: pointer to the device structure
+ *
+ * NOTE: This function is called by schedule work
+ * @return :
+ * none;
+ */
+void heci_bh_handler(struct work_struct *work)
+{
+	struct iamt_heci_device *device = container_of(work, struct iamt_heci_device, work);
+	struct io_heci_list complete_list;
+	__s32 slots;
+	int return_status;
+	struct heci_cb_private *kernel_priv_cb_pos = NULL, *kernel_priv_cb_next = NULL;
+	struct heci_file_private *file_extension = NULL;
+	int bus_message_received = FALSE;
+	struct task_struct *tsk;
+
+	DBG("function called after ISR to handle the interrupt processing.\n");
+	/* initialize our complete list */
+	spin_lock_bh(&device->device_lock);
+	heci_initialize_list(&complete_list, device);
+	device->host_hw_state = read_heci_register(device, H_CSR);
+	device->me_hw_state = read_heci_register(device, ME_CSR_HA);
+
+	/* check if ME wants a reset */
+	if (((device->me_hw_state & ME_RDY_HRA) == 0) &&
+			(device->heci_state != HECI_RESETING)
+			&& (device->heci_state != HECI_INITIALIZING)) {
+		DBG("FW not ready.\n");
+		heci_reset(device, TRUE);
+		spin_unlock_bh(&device->device_lock);
+		return;
+	}
+
+	/*  check if we need to start the device */
+	if ((device->host_hw_state & H_RDY) == 0) {
+
+		if ((device->me_hw_state & ME_RDY_HRA) == ME_RDY_HRA) {
+			DBG("we need to start the device.\n");
+			device->host_hw_state |= (H_IE | H_IG | H_RDY);
+			write_heci_register(device, H_CSR,
+					device->host_hw_state);
+			if (device->heci_state == HECI_INITIALIZING) {
+
+				device->received_message = TRUE;
+				spin_unlock_bh(&device->device_lock);
+				wake_up_interruptible(&device->
+						wait_received_message);
+				return;
+
+			} else {
+				spin_unlock_bh(&device->device_lock);
+				tsk = kthread_run(heci_initialize_clients,
+						device, "heci");
+				if (IS_ERR(tsk)) {
+					int rc = PTR_ERR(tsk);
+					printk(KERN_WARNING "heci: "
+							"Unable to start the thread for heci: %d\n",
+							rc);
+				}
+				return;
+			}
+
+
+		} else {
+			DBG("Enable interrupt FW not ready \n");
+			device->host_hw_state |= (H_IE);
+			write_heci_register(device, H_CSR,
+					device->host_hw_state);
+			spin_unlock_bh(&device->device_lock);
+			return;
+		}
+	}
+	/* check slots avalable for reading */
+	slots = count_full_read_slots(device);
+	DBG("slots =%08x  extra_write_index =%08x.\n", slots,
+			device->extra_write_index);
+	while ((slots > 0) && (!device->extra_write_index)) {
+		DBG("slots =%08x  extra_write_index =%08x.\n", slots,
+				device->extra_write_index);
+		DBG("call heci_bh_read_handler.\n");
+		return_status =
+			heci_bh_read_handler(&complete_list, device, &slots);
+		if (return_status != ESUCCESS)
+			goto end;
+	}
+	return_status =
+		heci_bh_write_handler(&complete_list, device, &slots);
+end:
+	DBG("end of bottom half function.\n");
+	device->host_hw_state = read_heci_register(device, H_CSR);
+	device->host_buffer_is_empty = host_buffer_is_empty(device);
+
+	if ((device->host_hw_state & H_IS) == H_IS) {
+		PREPARE_WORK(&device->work, heci_bh_handler);
+		DBG("schedule work the heci_bh_handler.\n");
+		return_status = schedule_work(&device->work);
+		if (!return_status)
+			ERR("schedule work the heci_bh_handler failed error=%x\n", return_status);
+	} else {
+		device->host_hw_state |= H_IE;
+	}
+
+	write_heci_register(device, H_CSR, device->host_hw_state);
+
+
+	if (device->received_message
+			&& waitqueue_active(&device->wait_received_message)) {
+		DBG("received waiting bus message\n");
+		bus_message_received = TRUE;
+	}
+	spin_unlock_bh(&device->device_lock);
+	if (bus_message_received) {
+		DBG("wake up device->wait_received_message\n");
+		wake_up_interruptible(&device->wait_received_message);
+		bus_message_received = FALSE;
+	}
+	if (complete_list.status != ESUCCESS || list_empty(&complete_list.heci_cb.cb_list)){
+		return;
+	}
+
+	list_for_each_entry_safe(kernel_priv_cb_pos, kernel_priv_cb_next, &complete_list.heci_cb.cb_list, cb_list){
+
+		file_extension =
+			(struct heci_file_private *) kernel_priv_cb_pos->
+			file_private;
+		list_del(&kernel_priv_cb_pos->cb_list);
+		if (file_extension && file_extension != &device->legacy_file_extension) {
+			DBG("completing call back.\n");
+			if (kernel_priv_cb_pos->major_file_operations == HECI_WRITE) {
+
+				kfree(kernel_priv_cb_pos-> request_buffer.data);
+				kernel_priv_cb_pos->request_buffer.data = NULL;
+				kfree(kernel_priv_cb_pos);
+				kernel_priv_cb_pos = NULL;
+				DBG("completing write  call back.\n");
+				file_extension->writing_state =
+					HECI_WRITE_COMPLETE;
+				if (&file_extension->tx_wait &&
+						waitqueue_active (&file_extension->tx_wait)) {
+					wake_up_interruptible
+						(&file_extension->tx_wait);
+				}
+			} else if (kernel_priv_cb_pos->major_file_operations == HECI_READ
+					&& HECI_READING == file_extension->reading_state) {
+				DBG("completing read call back information= %lu\n",
+						kernel_priv_cb_pos->information);
+				file_extension->reading_state = HECI_READ_COMPLETE;
+				if (&file_extension->rx_wait
+						&& waitqueue_active (&file_extension->rx_wait)) {
+					wake_up_interruptible
+						(&file_extension->rx_wait);
+				}
+
+			}
+		} else if (file_extension == &device->legacy_file_extension) {
+			if (device->legacy_canceled != TRUE) {
+				device->legacy_state = HECI_LEGACY_READ_COMPLETE;
+				device->legacy_stall_timer = 0;
+				memcpy(kernel_priv_cb_pos->response_buffer.
+						data,
+						device->
+						legacy_message_buffer,
+						device->
+						legacy_message_buffer_index);
+				list_add_tail(&kernel_priv_cb_pos->cb_list,
+						&device->
+						pthi_read_complete_list.
+						heci_cb.cb_list);
+				DBG("pthi read completed\n");
+			} else {
+				run_next_legacy_cmd(device);
+			}
+			if (&device->legacy_file_extension.wait) {
+				DBG("completing pthi call back.\n");
+				wake_up_interruptible(&device->
+						legacy_file_extension.
+						wait);
+
+			}
+
+		}
+	}
+	return;
+}
+
+
+/**
+ * heci_bh_read_handler - bottom half read routine after ISR to handle the read processing.
+ *
+ *
+ * @complete_list - An instance of our list structure
+ * @device_object - Device object for our driver
+ * @slots         - slots to read.
+ * @return :
+ *  0 on success,
+ *  negative on failure.
+ */
+int heci_bh_read_handler(struct io_heci_list *complete_list,
+		struct iamt_heci_device * device_object,
+		__s32 * slots)
+{
+	struct heci_message_header *heci_header;
+	int ret = ESUCCESS;
+	struct heci_file_private *file_extension_pos = NULL;
+	struct heci_file_private *file_extension_next = NULL;
+	if (!device_object->read_message_header) {
+		device_object->read_message_header =
+			read_heci_register(device_object, ME_CB_RW);
+		DBG("slots=%08x.\n", *slots);
+		(*slots)--;
+		DBG("slots=%08x.\n", *slots);
+	}
+	heci_header =
+		(struct heci_message_header *) & device_object->read_message_header;
+	DBG("heci_header->length =%d\n", heci_header->length);
+
+	if ((heci_header->reserved)
+			|| !(device_object->read_message_header)) {
+		DBG("corrupted message header.\n");
+		ret = -ECORRUPTED_MESSAGE_HEADER;
+		goto end;
+	}
+	if (heci_header->host_address || heci_header->me_address) {
+
+		list_for_each_entry_safe(file_extension_pos, file_extension_next, &device_object->file_list, link) {
+			DBG("list_for_each_entry_safe read host client = %d, ME client = %d\n",
+					file_extension_pos->host_client_id,
+					file_extension_pos->me_client_id);
+			if ((file_extension_pos->host_client_id == heci_header->host_address)
+					&& (file_extension_pos->me_client_id == heci_header->me_address))
+				break;
+		}
+
+		if (&file_extension_pos->link==&device_object->file_list) {
+			DBG("corrupted message header\n");
+			ret = -ECORRUPTED_MESSAGE_HEADER;
+			goto end;
+
+		}
+	}
+	if (((*slots) * sizeof(__u32)) < heci_header->length) {
+		DBG("we can't read the message slots=%08x.\n", *slots);
+		/* we can't read the message */
+		ret = -ERANGE;
+		goto end;
+	}
+
+
+	/* decide where to read the message too */
+	if (!heci_header->host_address) {
+		DBG("call heci_bh_read_bus_message.\n");
+		heci_bh_read_bus_message(device_object, heci_header);
+		DBG("end heci_bh_read_bus_message.\n");
+	} else if (heci_header->host_address ==
+			device_object->legacy_file_extension.host_client_id
+			&& HECI_FILE_CONNECTED ==
+			device_object->legacy_file_extension.state
+			&& device_object->legacy_state == HECI_LEGACY_READING) {
+		DBG("call heci_bh_read_legacy_message.\n");
+		DBG("heci_header->length =%d\n", heci_header->length);
+		ret =
+			heci_bh_read_pthi_message(complete_list, device_object,
+					heci_header);
+		if (ret != ESUCCESS)
+			goto end;
+	} else {
+		DBG("call heci_bh_read_client_message.\n");
+		ret = heci_bh_read_client_message(complete_list,
+				device_object,
+				heci_header);
+		if (ret != ESUCCESS)
+			goto end;
+	}
+
+	/* reset the number of slots and header */
+	*slots = count_full_read_slots(device_object);
+	device_object->read_message_header = 0;
+
+	if (*slots == -ESLOTS_OVERFLOW) {	/* overflow - reset */
+		DBG("reseting due to slots overflow\n");
+		/* set the event since message has been read */
+		ret = -ERANGE;
+		goto end;
+	}
+end:
+
+	return ret;
+
+}
+
+
+/**
+ * heci_bh_read_bus_message - bottom half read routine after ISR to handle the read bus message
+ * command  processing.
+ *
+ *
+ * @complete_list - An instance of our list structure
+ * @device_object - Device object for our driver
+ * @buffer        - message buffer will be filled
+ * @heci_header   - header of bus message
+ *
+ * @return :
+ * none;
+ */
+void heci_bh_read_bus_message(struct iamt_heci_device * device_object,
+		struct heci_message_header * heci_header)
+{
+	struct heci_bus_message *heci_message;
+	struct hbm_host_version_response *version_res;
+	struct hbm_client_connect_response *connect_res;
+	struct hbm_client_connect_response *disconnect_res;
+	struct hbm_flow_control *flow_control;
+	struct hbm_host_client_properties_response *properteis_res;
+	struct hbm_host_enumeration_response *enum_res;
+	struct hbm_client_disconnect_request *disconnect_req;
+	struct hbm_host_stop_request *h_stop_req;
+	int i;
+	unsigned char *buffer;
+	buffer = NULL;
+	/*  read the message to our buffer */
+	buffer = (unsigned char *) device_object->read_message_buffer;
+	BUG_ON(heci_header->length >=
+			sizeof(device_object->read_message_buffer));
+	heci_read_slots(device_object, buffer, heci_header->length);
+	heci_message = (struct heci_bus_message *) buffer;
+
+	switch (*(__u8 *) heci_message) {
+	case HOST_START_RES_CMD:
+		version_res = (struct hbm_host_version_response *) heci_message;
+		if (version_res->host_version_supported) {
+			device_object->version.major_version =
+				HBM_MAJOR_VERSION;
+			device_object->version.minor_version =
+				HBM_MINOR_VERSION;
+		} else {
+			device_object->version =
+				version_res->me_max_version;
+		}
+		device_object->received_message = TRUE;
+		DBG("host start response message received.\n");
+		break;
+
+	case CLIENT_CONNECT_RES_CMD:
+		connect_res =
+			(struct hbm_client_connect_response *) heci_message;
+		heci_client_connect_response(device_object, connect_res);
+		DBG("client connect response message received.\n");
+		wake_up(&device_object->wait_received_message);
+		break;
+
+	case CLIENT_DISCONNECT_RES_CMD:
+		disconnect_res =
+			(struct hbm_client_connect_response *) heci_message;
+		heci_client_disconnect_response(device_object,
+				disconnect_res);
+		DBG("client disconnect response message received.\n");
+		wake_up(&device_object->wait_received_message);
+		break;
+
+	case FLOW_CONTROL_CMD:
+		flow_control = (struct hbm_flow_control *) heci_message;
+		heci_client_flow_control_response(device_object,
+				flow_control);
+		DBG("client flow control response message received.\n");
+		break;
+	case HOST_CLIENT_PROPERTEIS_RES_CMD:
+		properteis_res =
+			(struct hbm_host_client_properties_response *) heci_message;
+
+
+		if (properteis_res->status != 0) {
+			BUG_ON(1);
+			break;
+		}
+		for (i = 0; i < device_object->num_heci_me_clients; i++) {
+			if (device_object->me_clients[i].client_id ==
+					properteis_res->address) {
+				device_object->me_clients[i].properteis =
+					properteis_res->client_properties;
+				break;
+			}
+
+		}
+		device_object->received_message = TRUE;
+		break;
+	case HOST_ENUM_RES_CMD:
+		enum_res =
+			(struct hbm_host_enumeration_response *) heci_message;
+		memcpy(device_object->heci_me_clients,
+				enum_res->valid_addresses, 32);
+		device_object->received_message = TRUE;
+		break;
+	case HOST_STOP_RES_CMD:
+		device_object->heci_state = HECI_DISABLED;
+		DBG("Reseting becase of FW stop response\n");
+		heci_reset(device_object, TRUE);
+		break;
+	case CLIENT_DISCONNECT_REQ_CMD:
+		/* search for client */
+		disconnect_req =
+			(struct hbm_client_disconnect_request *) heci_message;
+		heci_client_disconnect_request(device_object,
+				disconnect_req);
+		break;
+	case ME_STOP_REQ_CMD:
+		/* prepare stop request */
+		heci_header =
+			(struct heci_message_header *) & device_object->
+			extra_message_buffer[0];
+		heci_header->host_address = 0;
+		heci_header->me_address = 0;
+		heci_header->length = sizeof(struct hbm_host_stop_request);
+		heci_header->message_complete = 1;
+		heci_header->reserved = 0;
+		h_stop_req =
+			(struct hbm_host_stop_request *) & device_object->
+			extra_message_buffer[1];
+		memset(h_stop_req, 0, sizeof(struct hbm_host_stop_request));
+		h_stop_req->command.command = HOST_STOP_REQ_CMD;
+		h_stop_req->reason = DRIVER_STOP_REQUEST;
+		h_stop_req->reserved[0] = 0;
+		h_stop_req->reserved[1] = 0;
+		device_object->extra_write_index = 2;
+		break;
+
+	default:
+		BUG_ON(1);
+		break;
+
+	}
+
+	return;
+
+}
+
+/**
+ * heci_bh_read_legacy_message - bottom half read routine after ISR to handle the read legacy message
+ * data  processing.
+ *
+ *
+ * @complete_list - An instance of our list structure
+ * @device_object - Device object for our driver
+ * @buffer        - message buffer will be filled
+ * @heci_header   - header of legacy message
+ *
+ * @return :
+ *  0 on success,
+ *  negative on failure.
+ */
+int heci_bh_read_pthi_message(struct io_heci_list *complete_list,
+		struct iamt_heci_device * device_object,
+		struct heci_message_header * heci_header)
+{
+	struct heci_file_private *file_extension = NULL;
+	struct heci_cb_private *priv_cb = NULL;
+	int return_status = ESUCCESS;
+	unsigned char *buffer = NULL;
+	BUG_ON(heci_header->me_address !=
+			device_object->legacy_file_extension.me_client_id);
+	BUG_ON(device_object->legacy_state != HECI_LEGACY_READING);
+	buffer =
+		(unsigned char *) (device_object->legacy_message_buffer +
+				device_object->legacy_message_buffer_index);
+	BUG_ON(sizeof(device_object->legacy_message_buffer) <
+			(device_object->legacy_message_buffer_index +
+			 heci_header->length));
+	heci_read_slots(device_object, buffer, heci_header->length);
+
+	device_object->legacy_message_buffer_index += heci_header->length;
+
+	if (heci_header->message_complete) {
+		DBG("pthi_message_buffer_index=%d\n", heci_header->length);
+		DBG("completed  pthi read.\n ");
+		if (!device_object->legacy_current_cb)
+			return -ENODEV;
+		priv_cb = device_object->legacy_current_cb;
+		device_object->legacy_current_cb = NULL;
+		file_extension =
+			(struct heci_file_private *) priv_cb->file_private;
+		if (!file_extension)
+			return -ENODEV;
+		device_object->legacy_stall_timer = 0;
+		priv_cb->information =
+			device_object->legacy_message_buffer_index;
+		priv_cb->read_time = get_seconds();
+		if (device_object->legacy_ioctl
+				&& file_extension == &device_object->legacy_file_extension) {
+			/* found the legacy cb */
+			DBG("complete the pthi read cb.\n ");
+			if (&device_object->legacy_file_extension) {
+				DBG("add the pthi read cb to complete.\n ");
+				list_add_tail(&priv_cb->cb_list,
+						&complete_list->heci_cb.
+						cb_list);
+
+			}
+		}
+	}
+	return return_status;
+
+}
+
+/**
+ * heci_bh_read_client_message - bottom half read routine after ISR to handle the read heci client message
+ * data  processing.
+ *
+ *
+ * @complete_list - An instance of our list structure
+ * @device_object - Device object for our driver
+ * @buffer        - message buffer will be filled
+ * @heci_header   - header of heci client message
+ *
+ * @return :
+ *  0 on success,
+ *  negative on failure.
+ */
+int heci_bh_read_client_message(struct io_heci_list *complete_list,
+		struct iamt_heci_device * device_object,
+		struct heci_message_header * heci_header)
+{
+	struct heci_file_private *file_extension = NULL;
+	struct heci_cb_private *kernel_priv_cb_pos = NULL, *kernel_priv_cb_next = NULL;
+	unsigned char *buffer = NULL;
+	DBG ("Start client msg \n");
+	if (device_object->read_list.status == ESUCCESS
+			&& !list_empty(&device_object->read_list.heci_cb.cb_list)) {
+		list_for_each_entry_safe(kernel_priv_cb_pos, kernel_priv_cb_next, &device_object->
+				read_list.heci_cb.cb_list, cb_list){
+			file_extension = (struct heci_file_private *) kernel_priv_cb_pos->file_private;
+			if ((file_extension->host_client_id == heci_header->host_address)
+					&& (file_extension->me_client_id == heci_header->me_address)
+					&& (file_extension->state == HECI_FILE_CONNECTED)
+					&& (HECI_READ_COMPLETE != file_extension->reading_state)) {
+				spin_lock(&file_extension->read_io_lock);
+				file_extension->reading_state =
+					HECI_READING;
+				buffer = (unsigned char *) (kernel_priv_cb_pos->response_buffer.data +
+						kernel_priv_cb_pos->information);
+				BUG_ON(kernel_priv_cb_pos->response_buffer.size < heci_header->length +
+						kernel_priv_cb_pos->information);
+
+				if (kernel_priv_cb_pos->response_buffer.size < heci_header->length +
+						kernel_priv_cb_pos->information) {
+					DBG(" message overflow.\n");
+					list_del(&kernel_priv_cb_pos->cb_list);
+					spin_unlock(&file_extension->
+							read_io_lock);
+					return -ENOMEM;
+				}
+				if (buffer)
+					heci_read_slots(device_object,
+							buffer,
+							heci_header->
+							length);
+				kernel_priv_cb_pos->information +=
+					heci_header->length;
+				if (heci_header->message_complete) {
+					file_extension->status = ESUCCESS;
+					list_del(&kernel_priv_cb_pos->cb_list);
+					spin_unlock(&file_extension->
+							read_io_lock);
+					DBG("completed read host client = %d, ME client = %d, data length = %lu\n",
+							file_extension->host_client_id,
+							file_extension->me_client_id,
+							kernel_priv_cb_pos->information);
+					*(kernel_priv_cb_pos->response_buffer.data + kernel_priv_cb_pos->information) = '\0';
+					DBG("kernel_priv_cb_pos->response_buffer - %s\n",
+							kernel_priv_cb_pos->response_buffer.data);
+					list_add_tail(&kernel_priv_cb_pos->cb_list,
+							&complete_list->heci_cb.cb_list);
+				} else {
+					spin_unlock(&file_extension->
+							read_io_lock);
+				}
+
+				break;
+			}
+
+		}
+
+	}
+	DBG ("Message read\n");
+	if (!buffer) {
+		heci_read_slots(device_object,
+				(unsigned char *) device_object->
+				read_message_buffer, heci_header->length);
+		DBG("discarding message, header=%08x.\n",
+				*(__u32 *) device_object->read_message_buffer);
+	}
+
+	return ESUCCESS;
+}
+
+
+/**
+ * heci_bh_write_handler - bottom half write routine after ISR to handle the write processing.
+ *
+ *
+ * @complete_list - An instance of our list structure
+ * @device_object - Device object for our driver
+ * @slots         - slots to write.
+ * @return :
+ *  0 on success,
+ *  negative on failure.
+ */
+int heci_bh_write_handler(struct io_heci_list *complete_list,
+		struct iamt_heci_device * device_object,
+		__s32 * slots)
+{
+
+	struct heci_message_header *heci_header = NULL;
+	struct heci_file_private *file_extension = NULL;
+	struct heci_cb_private *kernel_priv_cb_pos = NULL, *kernel_priv_cb_next = NULL;
+
+
+	if (!host_buffer_is_empty(device_object)) {
+		DBG("host buffer is not empty.\n");
+		return ESUCCESS;
+	}
+	device_object->write_hang = -1;
+	*slots = count_empty_write_slots(device_object);
+	/* complete all waiting for write CB */
+	DBG("complete all waiting for write CB.\n");
+	if (device_object->write_waiting_list.status == ESUCCESS
+			&& !list_empty(&device_object->write_waiting_list.heci_cb.cb_list)) {
+		list_for_each_entry_safe(kernel_priv_cb_pos, kernel_priv_cb_next, &device_object->
+				write_waiting_list.heci_cb.cb_list, cb_list){
+			file_extension = (struct heci_file_private *) kernel_priv_cb_pos->file_private;
+			file_extension->status = ESUCCESS;
+			list_del(&kernel_priv_cb_pos->cb_list);
+			if (HECI_WRITING == file_extension->writing_state
+					&& kernel_priv_cb_pos->major_file_operations == HECI_WRITING
+					&& file_extension != &device_object->legacy_file_extension) {
+				DBG("HECI WRITE COMPLETE\n");
+				file_extension->writing_state = HECI_WRITE_COMPLETE;
+				list_add_tail(&kernel_priv_cb_pos->cb_list,
+						&complete_list->heci_cb.
+						cb_list);
+			}
+			if (file_extension == &device_object->legacy_file_extension) {
+				DBG("check legacy flow control\n");
+				if (device_object-> legacy_flow_control_pending) {
+					if (((*slots) * sizeof(__u32)) >= (sizeof(struct heci_message_header)
+								+ sizeof(struct hbm_flow_control))) {
+						*slots -= (sizeof(struct heci_message_header) +
+								sizeof(struct hbm_flow_control) + 3) / 4;
+						if (!heci_send_flow_control (device_object,
+									&device_object->legacy_file_extension)) {
+							DBG("legacy flow control failed\n");
+						} else {
+							DBG("legacy flow control success\n");
+							device_object->legacy_state = HECI_LEGACY_READING;
+							device_object->legacy_flow_control_pending = FALSE;
+							device_object->legacy_message_buffer_index = 0;
+							device_object->legacy_message_buffer_size = 0;
+							device_object->legacy_stall_timer = LEGACY_STALL_TIMER;
+							device_object->host_buffer_is_empty =
+								host_buffer_is_empty(device_object);
+						}
+					} else {
+						return -ECOMPLETE_MESSAGE;
+					}
+				}
+			}
+
+		}
+	}
+
+	if (device_object->stop && !device_object->wd_pending) {
+		device_object->wd_stoped = TRUE;
+		wake_up_interruptible(&device_object->wait_stop_wd);
+		return ESUCCESS;
+	}
+
+	if (device_object->extra_write_index != 0) {
+		DBG("extra_write_index =%d\n",
+				device_object->extra_write_index);
+		heci_write_message(device_object,
+				(struct heci_message_header *) &
+				device_object->extra_message_buffer[0],
+				(unsigned char *) &device_object->
+				extra_message_buffer[1],
+				(device_object->extra_write_index -
+				 1) * sizeof(__u32));
+		*slots -= device_object->extra_write_index;
+		device_object->extra_write_index = 0;
+	}
+	if (device_object->heci_state == HECI_ENABLED){
+		if (device_object->wd_pending
+				&& flow_control_credentials(device_object,
+					&device_object->wd_file_extension)) {
+			if (!heci_send_wd(device_object))
+				DBG("Wd send failed\n");
+			else
+				flow_control_reduce(device_object,
+						&device_object->
+						wd_file_extension);
+			device_object->wd_pending = 0;
+
+			if (device_object->wd_timeout != 0) {
+				*slots -=
+					(sizeof(struct heci_message_header) +
+					 HECI_START_WD_DATA_SIZE + 3) / 4;
+				device_object->wd_due_counter = 2;
+			} else {
+				*slots -=
+					(sizeof(struct heci_message_header) +
+					 HECI_WD_PARAMS_SIZE + 3) / 4;
+				device_object->wd_due_counter = 0;
+			}
+
+		}
+	}
+	if (device_object->stop)
+		return ~ENODEV;
+
+	/* complete control write list CB */
+	if (device_object->control_write_list.status == ESUCCESS) {
+		/* complete control write list CB */
+		DBG("complete control write list CB\n ");
+		list_for_each_entry_safe(kernel_priv_cb_pos, kernel_priv_cb_next, &device_object->
+				control_write_list.heci_cb.cb_list, cb_list){
+			file_extension =
+				(struct heci_file_private *) kernel_priv_cb_pos->
+				file_private;
+			if (!file_extension) {
+				list_del(&kernel_priv_cb_pos->cb_list);
+				return -ENODEV;
+			}
+			switch (kernel_priv_cb_pos->major_file_operations) {
+			case HECI_CLOSE:
+				/* send disconnect message */
+				if ((*slots * sizeof(__u32)) >= (sizeof(struct heci_message_header) +
+							sizeof(struct hbm_client_disconnect_request))) {
+					*slots -= (sizeof(struct heci_message_header) +
+							sizeof(struct hbm_client_disconnect_request) + 3) / 4;
+					if (!heci_disconnect(device_object,
+								file_extension)) {
+						file_extension->status = ESUCCESS;
+						kernel_priv_cb_pos->information = 0;
+						list_del(&kernel_priv_cb_pos->cb_list);
+						list_add_tail(&kernel_priv_cb_pos->cb_list,
+								&complete_list->heci_cb.
+								cb_list);
+						return -ECOMPLETE_MESSAGE;
+					} else {
+						file_extension->state = HECI_FILE_DISCONNECTING;
+						file_extension->status = ESUCCESS;
+						kernel_priv_cb_pos->information = 0;
+						list_del(&kernel_priv_cb_pos->cb_list);
+						list_add_tail(&kernel_priv_cb_pos->cb_list,
+								&device_object->control_read_list.
+								heci_cb.cb_list);
+						file_extension->timer_count = CONNECT_TIMEOUT;
+					}
+				} else {
+					/* return the cancel routine */
+					return -ECORRUPTED_MESSAGE_HEADER;
+				}
+				break;
+			case HECI_READ:
+				/* send flow control message */
+				if ((*slots * sizeof(__u32)) >= (sizeof(struct heci_message_header) +
+							sizeof(struct hbm_flow_control))) {
+					*slots -= (sizeof(struct heci_message_header) +
+							sizeof(struct hbm_flow_control) + 3) / 4;
+					if (!heci_send_flow_control(device_object, file_extension)) {
+						file_extension->status = -ENODEV;
+						kernel_priv_cb_pos->information = 0;
+						list_del(&kernel_priv_cb_pos->cb_list);
+						list_add_tail(&kernel_priv_cb_pos->cb_list,
+								&complete_list->heci_cb.
+								cb_list);
+						return -ENODEV;
+
+					} else {
+						list_del(&kernel_priv_cb_pos->cb_list);
+						list_add_tail(&kernel_priv_cb_pos->cb_list,
+								&device_object->read_list.
+								heci_cb.cb_list);
+					}
+				} else {
+					/* return the cancel routine */
+					list_del(&kernel_priv_cb_pos->cb_list);
+					return -ECORRUPTED_MESSAGE_HEADER;
+				}
+				break;
+			case HECI_IOCTL:
+				/* connect message */
+				if (!other_client_is_connecting(device_object, file_extension)) {
+					continue;
+				}
+				if ((*slots * sizeof(__u32)) >= (sizeof(struct heci_message_header) +
+							sizeof(struct hbm_client_connect_request))) {
+					file_extension->state = HECI_FILE_CONNECTING;
+					*slots -= (sizeof(struct heci_message_header) +
+							sizeof(struct hbm_client_connect_request) + 3) / 4;
+					if (!heci_connect(device_object, file_extension)) {
+						file_extension->status = -ENODEV;
+						kernel_priv_cb_pos->information = 0;
+						list_del(&kernel_priv_cb_pos->cb_list);
+						return -ENODEV;
+					} else {
+						list_del(&kernel_priv_cb_pos->cb_list);
+						list_add_tail(&kernel_priv_cb_pos->cb_list,
+								&device_object->control_read_list.
+								heci_cb.cb_list);
+						file_extension->timer_count = CONNECT_TIMEOUT;
+					}
+				} else {
+					/* return the cancel routine */
+					list_del(&kernel_priv_cb_pos->cb_list);
+					return -ECORRUPTED_MESSAGE_HEADER;
+				}
+				break;
+
+			default:
+				BUG_ON(1);
+			}
+
+		}
+	}
+	/* complete  write list CB */
+	if (device_object->write_list.status == ESUCCESS
+			&& !list_empty(&device_object->write_list.heci_cb.cb_list)) {
+		DBG("complete write list CB \n");
+		list_for_each_entry_safe(kernel_priv_cb_pos, kernel_priv_cb_next, &device_object->
+				write_list.heci_cb.cb_list, cb_list){
+			file_extension = (struct heci_file_private *) kernel_priv_cb_pos->file_private;
+
+			if ((file_extension != NULL)
+					&& (file_extension != &device_object->legacy_file_extension)) {
+				if (!flow_control_credentials(device_object,
+							file_extension)) {
+					DBG("No flow control credentials for client %d, not sending\n",
+							file_extension->host_client_id);
+					continue;
+				}
+				if ((*slots * sizeof(__u32)) >= (sizeof(struct heci_message_header) +
+							(kernel_priv_cb_pos->request_buffer.size - kernel_priv_cb_pos->information))) {
+					heci_header = (struct heci_message_header *) & device_object->write_message_buffer[0];
+					heci_header->host_address = file_extension->host_client_id;
+					heci_header->me_address = file_extension->me_client_id;
+					heci_header->length = ((kernel_priv_cb_pos->request_buffer.size) -
+							(kernel_priv_cb_pos->information));
+					heci_header->message_complete = 1;
+					heci_header->reserved = 0;
+					DBG("kernel_priv_cb_pos->request_buffer.size =%d  heci_header->message_complete= %d\n",
+							kernel_priv_cb_pos->request_buffer.size,
+							heci_header->message_complete);
+					DBG("kernel_priv_cb_pos->information  =%lu\n",
+							kernel_priv_cb_pos->information);
+					DBG("heci_header->length  =%d\n",
+							heci_header->length);
+					*slots -= (sizeof(struct heci_message_header) + heci_header->length + 3) / 4;
+					if (!heci_write_message (device_object, heci_header,
+								(unsigned char *) (kernel_priv_cb_pos-> request_buffer.data + kernel_priv_cb_pos->information),
+								heci_header->length)) {
+						file_extension->status = -ENODEV;
+						list_del(&kernel_priv_cb_pos->cb_list);
+						list_add_tail(&kernel_priv_cb_pos->cb_list,
+								&complete_list->heci_cb.
+								cb_list);
+						return -ENODEV;
+					} else {
+						flow_control_reduce
+							(device_object, file_extension);
+						file_extension->status = ESUCCESS;
+						kernel_priv_cb_pos->information += heci_header->length;
+						list_del(&kernel_priv_cb_pos->cb_list);
+						list_add_tail(&kernel_priv_cb_pos->cb_list,
+								&device_object->write_waiting_list.
+								heci_cb.cb_list);
+					}
+				} else if (*slots == ((device_object->host_hw_state & H_CBD) >> 24)) {	/* buffer is still empty */
+					heci_header = (struct heci_message_header *) & device_object->write_message_buffer[0];
+					heci_header->host_address = file_extension->host_client_id;
+					heci_header->me_address = file_extension->me_client_id;
+					heci_header->length = (*slots * sizeof(__u32)) - sizeof(struct heci_message_header);
+					heci_header->message_complete = 0;
+					heci_header->reserved = 0;
+
+					(*slots) -= (sizeof(struct heci_message_header) + heci_header->length + 3) / 4;
+					if (!heci_write_message(device_object, heci_header,
+								(unsigned char *) (kernel_priv_cb_pos->request_buffer.  data + kernel_priv_cb_pos->information),
+								heci_header->length)) {
+						file_extension->status = -ENODEV;
+						list_del(&kernel_priv_cb_pos->cb_list);
+						list_add_tail(&kernel_priv_cb_pos->cb_list, &complete_list->heci_cb.cb_list);
+						return -ENODEV;
+					} else {
+						kernel_priv_cb_pos->information += heci_header->length;
+						DBG("kernel_priv_cb_pos->request_buffer.size =%d  heci_header->message_complete= %d\n",
+								kernel_priv_cb_pos->request_buffer.size,
+								heci_header->message_complete);
+						DBG("kernel_priv_cb_pos->information  =%lu\n", kernel_priv_cb_pos->information);
+						DBG("heci_header->length  =%d\n", heci_header->length);
+					}
+					return -ECOMPLETE_MESSAGE;
+				} else {
+					return -ECORRUPTED_MESSAGE_HEADER;
+				}
+			} else if (file_extension == &device_object->legacy_file_extension) {	/* LEGACY IOCTL */
+				DBG("complete pthi write cb\n");
+				if (!flow_control_credentials(device_object, file_extension)) {
+					DBG("No flow control credentials for pthi client %d, not sending\n",
+							file_extension->host_client_id);
+					continue;
+				}
+				if ((*slots * sizeof(__u32)) >= (sizeof(struct heci_message_header) +
+							device_object->legacy_message_buffer_size - device_object->legacy_message_buffer_index)) {
+					heci_header = (struct heci_message_header *) & device_object->write_message_buffer[0];
+					heci_header->host_address = file_extension->host_client_id;
+					heci_header->me_address = file_extension->me_client_id;
+					heci_header->length = device_object->legacy_message_buffer_size -
+						device_object->legacy_message_buffer_index;
+					heci_header->message_complete = 1;
+					heci_header->reserved = 0;
+
+					*slots -= (sizeof(struct heci_message_header) + heci_header->length + 3) / 4;
+
+					if (!heci_write_message (device_object, heci_header,
+								(device_object->legacy_message_buffer + device_object->legacy_message_buffer_index),
+								heci_header->length)) {
+						device_object->legacy_state = HECI_LEGACY_IDLE;
+						file_extension->status = -ENODEV;
+						list_del(&kernel_priv_cb_pos->cb_list);
+						return -ENODEV;
+					} else {
+						flow_control_reduce (device_object, file_extension);
+						device_object->legacy_message_buffer_index += heci_header->length;
+						list_del(&kernel_priv_cb_pos->cb_list);
+						kernel_priv_cb_pos->information = device_object->legacy_message_buffer_index;
+						file_extension->status = ESUCCESS;
+						device_object->legacy_state = HECI_LEGACY_FLOW_CONTROL;
+						device_object->legacy_flow_control_pending = TRUE;
+						/* save legacy cb sent to pthi client */
+						device_object->legacy_current_cb = kernel_priv_cb_pos;
+						list_add_tail(&kernel_priv_cb_pos->cb_list,
+								&device_object->write_waiting_list.heci_cb.  cb_list);
+
+					}
+				} else if (*slots == ((device_object->host_hw_state & H_CBD) >> 24)) {	/* buffer is still empty */
+					heci_header = (struct heci_message_header *) & device_object->write_message_buffer[0];
+					heci_header->host_address = file_extension->host_client_id;
+					heci_header->me_address = file_extension->me_client_id;
+					heci_header->length = (*slots * sizeof(__u32)) - sizeof(struct heci_message_header);
+					heci_header->message_complete = 0;
+					heci_header->reserved = 0;
+
+					*slots -= (sizeof(struct heci_message_header) + heci_header->length + 3) / 4;
+
+					if (!heci_write_message (device_object, heci_header, (device_object->legacy_message_buffer +
+									device_object->legacy_message_buffer_index), heci_header->length)) {
+						file_extension->status = -ENODEV;
+						list_del(&kernel_priv_cb_pos->cb_list);
+					} else {
+						device_object->legacy_message_buffer_index += heci_header->length;
+					}
+					return -ECOMPLETE_MESSAGE;
+				} else {
+					return -ECORRUPTED_MESSAGE_HEADER;;
+				}
+			}
+
+		}
+
+	}
+	return ESUCCESS;
+}
+
+
+/**
+ * is_treat_specially_client  - check if the message belong
+ * to the file extension .
+ * @file_extension -extension of the file object
+ * @connect_res    -connect response bus message
+ * @device_object -Device object for our driver
+ *
+ * @return :
+ * TRUE if empty
+ * FALSE - otherwise.
+ */
+int is_treat_specially_client(struct heci_file_private * file_extension,
+		struct hbm_client_connect_response *
+		connect_res)
+{
+	int ret = FALSE;
+	if ((file_extension->host_client_id == connect_res->host_address)
+			&& (file_extension->me_client_id == connect_res->me_address)) {
+
+		if (connect_res->status == 0) {
+			DBG("client connect status = 0x%08x.\n",
+					connect_res->status);
+			file_extension->state = HECI_FILE_CONNECTED;
+			file_extension->status = ESUCCESS;
+		} else {
+			DBG("client connect status = 0x%08x.\n",
+					connect_res->status);
+			file_extension->state = HECI_FILE_DISCONNECTED;
+			file_extension->status = -ENODEV;
+		}
+		ret = TRUE;
+	}
+	DBG("client state = %d.\n", file_extension->state);
+	return ret;
+
+}
+
+/**
+ * heci_client_connect_response  - connect response bh routine
+ *
+ * @device_object -Device object for our driver
+ * @connect_res    -connect response bus message
+ * @complete_list - An instance of our list structure
+ *
+ * @return :
+ * none;
+ */
+void heci_client_connect_response(struct iamt_heci_device * device_object,
+		struct hbm_client_connect_response *
+		connect_res)
+{
+
+	struct heci_file_private *file_extension = NULL;
+	struct heci_cb_private *kernel_priv_cb_pos = NULL, *kernel_priv_cb_next = NULL;
+
+	/* if WD or legacy client treat specially */
+
+	if ((is_treat_specially_client(&(device_object->wd_file_extension),
+					connect_res))
+			|| (is_treat_specially_client(&
+					(device_object->
+					 legacy_file_extension),
+					connect_res))) {
+		return;
+	}
+
+	if (device_object->control_read_list.status == ESUCCESS
+			&& !list_empty(&device_object->control_read_list.heci_cb.
+				cb_list)) {
+		list_for_each_entry_safe(kernel_priv_cb_pos, kernel_priv_cb_next, &device_object->control_read_list.heci_cb.cb_list, cb_list){
+			file_extension =
+				(struct heci_file_private *) kernel_priv_cb_pos->
+				file_private;
+			if (!file_extension) {
+				list_del(&kernel_priv_cb_pos->cb_list);
+				return;
+			}
+			if (HECI_IOCTL == kernel_priv_cb_pos->major_file_operations) {
+
+				if (is_treat_specially_client (file_extension, connect_res)) {
+					list_del(&kernel_priv_cb_pos->cb_list);
+					file_extension->status = ESUCCESS;
+					file_extension->timer_count = 0;
+					break;
+				}
+			}
+		}
+	}
+	return;
+}
+
+/**
+ * heci_client_disconnect_response  - disconnect response bh routine
+ *
+ * @device_object -Device object for our driver
+ * @disconnect_res    -disconnect response bus message
+ * @complete_list - An instance of our list structure
+ *
+ * @return :
+ * none;
+ */
+void heci_client_disconnect_response(struct iamt_heci_device * device_object,
+		struct hbm_client_connect_response *
+		disconnect_res)
+{
+	struct heci_file_private *file_extension = NULL;
+	struct heci_cb_private *kernel_priv_cb_pos = NULL, *kernel_priv_cb_next = NULL;
+	if (device_object->control_read_list.status == ESUCCESS
+			&& !list_empty(&device_object->control_read_list.heci_cb.
+				cb_list)) {
+		list_for_each_entry_safe(kernel_priv_cb_pos, kernel_priv_cb_next, &device_object->control_read_list.heci_cb.cb_list, cb_list){
+			file_extension =
+				(struct heci_file_private *) kernel_priv_cb_pos->
+				file_private;
+
+			if (!file_extension) {
+				list_del(&kernel_priv_cb_pos->cb_list);
+				return;
+			}
+
+			DBG("list_for_each_entry_safe in control_read_list.\n");
+			if ((file_extension->host_client_id == disconnect_res->host_address)
+					&& (file_extension->me_client_id == disconnect_res->me_address)) {
+				list_del(&kernel_priv_cb_pos->cb_list);
+				if (disconnect_res->status == 0)
+					file_extension->state = HECI_FILE_DISCONNECTED;
+				file_extension->status = ESUCCESS;
+				file_extension->timer_count = 0;
+				break;
+			}
+		}
+	}
+	return;
+}
+
+/**
+ * heci_client_flow_control_response  - flow control response bh routine
+ *
+ * @device_object -Device object for our driver
+ * @flow_control    -flow control response bus message
+ *
+ * @return :
+ * none;
+ */
+void heci_client_flow_control_response(struct iamt_heci_device * device_object,
+		struct hbm_flow_control * flow_control)
+{
+	struct heci_file_private *file_extension_pos = NULL;
+	struct heci_file_private *file_extension_next = NULL;
+	int i;
+	if (flow_control->host_address == 0) {	/* single receive buffer */
+		for (i = 0; i < device_object->num_heci_me_clients; i++) {
+			if (flow_control->me_address ==
+					device_object->me_clients[i].client_id) {
+				if (device_object->me_clients[i].properteis.single_receive_buffer != 0) {
+					device_object->me_clients[i].
+						flow_control_credentials++;
+					DBG("received flow control message for ME client %d (single receive buffer).\n",
+							flow_control->me_address);
+					DBG("flow control credentials=%d.\n",
+							device_object->me_clients[i].flow_control_credentials);
+				} else {
+					BUG_ON(1);	/* error in flow control */
+				}
+			}
+		}
+	} else {		/* normal connection */
+		list_for_each_entry_safe(file_extension_pos, file_extension_next, &device_object->file_list, link) {
+			DBG("list_for_each_entry_safe in file_list\n");
+
+			DBG("file_extension  of host client %d ME client %d.\n",
+					file_extension_pos->host_client_id,
+					file_extension_pos->me_client_id);
+			DBG("flow control message for host client %d ME client %d.\n",
+					flow_control->host_address,
+					flow_control->me_address);
+			if ((file_extension_pos->host_client_id == flow_control->host_address)
+					&& (file_extension_pos->me_client_id == flow_control->me_address)) {
+				DBG("received flow control message for host client %d ME client %d.\n",
+						flow_control->host_address,
+						flow_control->me_address);
+				file_extension_pos->flow_control_credentials++;
+				DBG("flow control credentials=%d.\n",
+						file_extension_pos->flow_control_credentials);
+				break;
+			}
+		}
+	}
+	return;
+}
+
+/**
+ * heci_client_disconnect_request  - disconnect request bh routine
+ *
+ * @device_object -Device object for our driver
+ * @disconnect_req    -disconnect request bus message
+ *
+ * @return :
+ * none;
+ */
+void heci_client_disconnect_request(struct iamt_heci_device * device_object,
+		struct hbm_client_disconnect_request *
+		disconnect_req)
+{
+	struct heci_message_header *heci_header;
+	struct hbm_client_connect_response *disconnect_res;
+	struct heci_file_private *file_extension_pos = NULL;
+	struct heci_file_private *file_extension_next = NULL;
+
+	list_for_each_entry_safe(file_extension_pos, file_extension_next, &device_object->file_list, link) {
+		if ((file_extension_pos->host_client_id == disconnect_req->host_address)
+				&& (file_extension_pos->me_client_id == disconnect_req->me_address)) {
+			DBG("received disconnect request for host client %d ME client %d.\n",
+					disconnect_req->host_address,
+					disconnect_req->me_address);
+			file_extension_pos->state = HECI_FILE_DISCONNECTED;
+			file_extension_pos->timer_count = 0;
+			if (file_extension_pos == &device_object->wd_file_extension) {
+				device_object->wd_due_counter = 0;
+				device_object->wd_pending = FALSE;
+			} else if (file_extension_pos ==
+					&device_object->legacy_file_extension) {
+				device_object->legacy_timer = 0;
+			}
+
+			/* prepare disconnect response */
+			heci_header = (struct heci_message_header *) & device_object->extra_message_buffer[0];
+			heci_header->host_address = 0;
+			heci_header->me_address = 0;
+			heci_header->length = sizeof(struct hbm_client_connect_response);
+			heci_header->message_complete = 1;
+			heci_header->reserved = 0;
+
+			disconnect_res = (struct hbm_client_connect_response *) &
+				device_object->extra_message_buffer[1];
+			disconnect_res->host_address =
+				file_extension_pos->host_client_id;
+			disconnect_res->me_address = file_extension_pos->me_client_id;
+			*(__u8 *) (&disconnect_res->command) = CLIENT_DISCONNECT_RES_CMD;
+			disconnect_res->status = 0;
+			device_object->extra_write_index = 2;
+			break;
+		}
+	}
+	return;
+}
+
+
+/**
+ * heci_timer - timer function .
+ * @data: pointer to the device structure
+ *
+ * NOTE: This function is called by timer interrupt work
+ * @return :
+ * none;
+ */
+void heci_wd_timer(unsigned long data)
+{
+	struct iamt_heci_device *device = (struct iamt_heci_device *) data;
+	DBG("send watchdog.\n");
+	spin_lock_bh(&device->device_lock);
+	if (device->heci_state != HECI_ENABLED) {
+		mod_timer(&device->wd_timer, round_jiffies(jiffies + 2 * HZ));
+		spin_unlock_bh(&device->device_lock);
+		return;
+	}
+	if (device->wd_file_extension.state != HECI_FILE_CONNECTED) {
+		mod_timer(&device->wd_timer, round_jiffies(jiffies + 2 * HZ));
+		spin_unlock_bh(&device->device_lock);
+		return;
+	}
+	/*** Watchdog ***/
+	if (device->wd_due_counter != 0 && FALSE == device->wd_bypass) {
+		if (--device->wd_due_counter == 0) {
+			if (device->host_buffer_is_empty &&
+					flow_control_credentials(device,
+						&device->
+						wd_file_extension)) {
+				device->host_buffer_is_empty = FALSE;
+
+				if (!heci_send_wd(device))
+					DBG("Wd send failed\n");
+				else
+					flow_control_reduce(device,
+							&device->
+							wd_file_extension);
+				if (device->wd_timeout != 0)
+					device->wd_due_counter = 2;
+				else
+					device->wd_due_counter = 0;
+			} else {
+				device->wd_pending = TRUE;
+			}
+		}
+	}
+	if (device->legacy_stall_timer != 0) {
+		if (--device->legacy_stall_timer == 0) {
+			DBG("Reseting because of hang to PTHI\n");
+			heci_reset(device, TRUE);
+			device->legacy_message_buffer_size = 0;
+			device->legacy_message_buffer_index = 0;
+			device->legacy_canceled = FALSE;
+			device->legacy_ioctl = TRUE;
+			device->legacy_state = HECI_LEGACY_IDLE;
+			device->legacy_timer = 0;
+			spin_unlock_bh(&device->device_lock);
+
+			if (device->legacy_current_cb) {
+				kfree(device->legacy_current_cb->request_buffer.data);
+				device->legacy_current_cb->request_buffer.data = NULL;
+				kfree(device->legacy_current_cb->response_buffer.data);
+				device->legacy_current_cb->response_buffer.data = NULL;
+				kfree(device->legacy_current_cb);
+			}
+			spin_lock_bh(&device->device_lock);
+			device->legacy_file_object = NULL;
+			device->legacy_current_cb = NULL;
+			run_next_legacy_cmd(device);
+		}
+	}
+	mod_timer(&device->wd_timer, round_jiffies(jiffies + 2 * HZ));
+	spin_unlock_bh(&device->device_lock);
+	return;
+}
diff -Nurp linux-2.6.37/3rdparty/heci/io_heci.c linux-2.6.37.3rdparty/3rdparty/heci/io_heci.c
--- linux-2.6.37/3rdparty/heci/io_heci.c	1970-01-01 02:00:00.000000000 +0200
+++ linux-2.6.37.3rdparty/3rdparty/heci/io_heci.c	2008-01-24 14:04:22.000000000 +0200
@@ -0,0 +1,1138 @@
+/*
+ * Part of Intel(R) Manageability Engine Interface Linux driver
+ *
+ * Copyright (c) 2003 - 2007 Intel Corp.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions, and the following disclaimer,
+ *    without modification.
+ * 2. Redistributions in binary form must reproduce at minimum a disclaimer
+ *    substantially similar to the "NO WARRANTY" disclaimer below
+ *    ("Disclaimer") and any redistribution must be conditioned upon
+ *    including a substantially similar Disclaimer requirement for further
+ *    binary redistribution.
+ * 3. Neither the names of the above-listed copyright holders nor the names
+ *    of any contributors may be used to endorse or promote products derived
+ *    from this software without specific prior written permission.
+ *
+ * Alternatively, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") version 2 as published by the Free
+ * Software Foundation.
+ *
+ * NO WARRANTY
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGES.
+ *
+ */
+
+#include <linux/module.h>
+#include <linux/moduleparam.h>
+#include <linux/kernel.h>
+#include <linux/slab.h>
+#include <linux/fs.h>
+#include <linux/errno.h>
+#include <linux/types.h>
+#include <linux/fcntl.h>
+#include <linux/aio.h>
+#include <linux/pci.h>
+#include <linux/reboot.h>
+#include <linux/poll.h>
+#include <linux/init.h>
+#include <linux/kdev_t.h>
+#include <linux/ioctl.h>
+#include <linux/cdev.h>
+#include <linux/list.h>
+#include <asm/uaccess.h>
+#include <asm/unistd.h>
+#include <linux/delay.h>
+
+#include "heci_data_structures.h"
+#include "heci.h"
+#include "heci_interface.h"
+#include "version.h"
+
+
+/**
+ * heci_ioctl_get_version - the get driver version IOCTL function
+ * @device_object -Device object for our driver
+ * @if_num  minor number
+ * @*u_msg pointer to user data struct in user space
+ * @k_msg data in kernel on the stack
+ * @file_extension -extension of the file object
+ *
+ * @return :
+ *  0 on success,
+ *  negative on failure.
+ */
+int heci_ioctl_get_version(struct iamt_heci_device * device, int if_num,
+			   struct heci_message_data *u_msg,
+			   struct heci_message_data k_msg,
+			   struct heci_file_private * file_extension)
+{
+
+	int return_status = ESUCCESS;
+	struct heci_driver_version *version;
+	struct heci_message_data res_msg;
+	res_msg.data = NULL;
+	if ((if_num != HECI_MINOR_NUMBER) || (!device)
+	    || (!file_extension))
+		return -ENODEV;
+
+
+	if (k_msg.size < (sizeof(struct heci_driver_version) - 2)) {
+		DBG("user buffer less than heci_driver_version.\n");
+		return -EMSGSIZE;
+	}
+
+	res_msg.data = kmalloc(sizeof(struct heci_driver_version), GFP_KERNEL);
+	if (!res_msg.data) {
+		DBG("failed allocation response buffer size = %d.\n",
+		    (int) sizeof(struct heci_driver_version));
+		return -ENOMEM;
+
+	}
+	version = (struct heci_driver_version *) res_msg.data;
+	version->major = MAJOR_VERSION;
+	version->minor = MINOR_VERSION;
+	version->hotfix = QUICK_FIX_NUMBER;
+	if (k_msg.size < sizeof(struct heci_driver_version)) {
+		res_msg.size = sizeof(struct heci_driver_version) - 2;
+	} else {
+		version->build = VER_BUILD;
+		res_msg.size = sizeof(struct heci_driver_version);
+	}
+	return_status = file_extension->status;
+	/* now copy the data to user space */
+	if (copy_to_user(k_msg.data, res_msg.data, res_msg.size)) {
+		return_status = -EFAULT;
+		goto end;
+	}
+	if (put_user(res_msg.size, &u_msg->size)) {
+		return_status = -EFAULT;
+		goto end;
+	}
+end:
+	kfree(res_msg.data);
+	return return_status;
+}
+
+/**
+ * heci_ioctl_connect_client - the connect to fw client IOCTL function
+ * @device_object -Device object for our driver
+ * @if_num  minor number
+ * @*u_msg pointer to user data struct in user space
+ * @k_msg data in kernel on the stack
+ * @file_extension -extension of the file object
+ *
+ * @return :
+ *  0 on success,
+ *  negative on failure.
+ */
+int heci_ioctl_connect_client(struct iamt_heci_device * device, int if_num,
+			      struct heci_message_data *u_msg,
+			      struct heci_message_data k_msg,
+			      struct file *file)
+{
+
+	int return_status = ESUCCESS;
+	struct heci_message_data req_msg, res_msg;
+	struct heci_cb_private *kernel_priv_cb = NULL;
+	struct heci_client *client;
+	struct heci_file_private *file_extension = NULL;
+    struct heci_file_private *file_extension_pos = NULL;
+	struct heci_file_private *file_extension_next = NULL;
+	struct heci_file_private *file_extension_list_temp = NULL;
+
+        struct heci_cb_private *kernel_priv_cb_pos = NULL, *kernel_priv_cb_next = NULL;
+	long timeout = 15;	/*15 second */
+	__u8 i;
+	int err = 0;
+	res_msg.data = NULL;
+	req_msg.data = NULL;
+	if ((if_num != HECI_MINOR_NUMBER) || (!device)
+	    || (!file))
+		return -ENODEV;
+	file_extension = file->private_data;
+	if (!file_extension)
+		return -ENODEV;
+	if (k_msg.size != sizeof(struct guid)) {
+		DBG("user buffer size is not equal to size of struct guid(16).\n");
+		return -EMSGSIZE;
+	}
+	req_msg.data = kmalloc(sizeof(struct guid), GFP_KERNEL);
+	res_msg.data = kmalloc(sizeof(struct heci_client), GFP_KERNEL);
+
+
+	if (!res_msg.data) {
+		DBG("failed allocation response buffer size = %d.\n",
+				(int) sizeof(struct heci_client));
+		if (req_msg.data) {
+			kfree(req_msg.data);
+			req_msg.data = NULL;
+			goto fail;
+		}
+	}
+	if (!req_msg.data) {
+		DBG("failed allocation request buffer size = %d.\n",
+				(int) sizeof(struct guid));
+		if (res_msg.data) {
+			kfree(res_msg.data);
+			res_msg.data = NULL;
+			goto fail;
+		}
+	      fail:
+		return -ENOMEM;
+	}
+	req_msg.size = sizeof(struct guid);
+	res_msg.size = sizeof(struct heci_client);
+	if (!k_msg.data) {
+		return_status = -EIO;
+		goto end;
+	}
+
+	/* copy the message to kernel space - use a pointer already copied into kernel space */
+	if (copy_from_user(req_msg.data, k_msg.data, k_msg.size)) {
+		return_status = -EFAULT;
+		goto end;
+	}
+	/* buffered ioctl cb */
+	kernel_priv_cb =
+	    kmalloc(sizeof(struct heci_cb_private), GFP_KERNEL);
+	if (!kernel_priv_cb) {
+		return_status = -ENOMEM;
+		goto end;
+	}
+	INIT_LIST_HEAD(&kernel_priv_cb->cb_list);
+	kernel_priv_cb->response_buffer.data = res_msg.data;
+	kernel_priv_cb->response_buffer.size = res_msg.size;
+	kernel_priv_cb->request_buffer.data = req_msg.data;
+	kernel_priv_cb->request_buffer.size = req_msg.size;
+	kernel_priv_cb->major_file_operations = HECI_IOCTL;
+	spin_lock_bh(&device->device_lock);
+	if (device->heci_state != HECI_ENABLED) {
+		return_status = -ENODEV;
+		spin_unlock_bh(&device->device_lock);
+		goto end;
+	}
+	if ((file_extension->state != HECI_FILE_INITIALIZING) &&
+	    (file_extension->state != HECI_FILE_DISCONNECTED)) {
+		return_status = -EBUSY;
+		spin_unlock_bh(&device->device_lock);
+		goto end;
+	}
+
+	/* find ME client we're trying to connect to */
+	for (i = 0; i < device->num_heci_me_clients; i++) {
+		if (0 == memcmp((struct guid *) req_msg.data,
+			&device->me_clients[i].properteis.protocol_name,
+			sizeof(struct guid))) {
+			if (device->me_clients[i].properteis.fixed_address == 0) {
+				file_extension->me_client_id =
+				    device->me_clients[i].client_id;
+				file_extension->state =
+				    HECI_FILE_CONNECTING;
+			}
+			break;
+		}
+	}
+	/*if we're connecting to PTHI client so we will use the exist connection */
+	if (0 == memcmp((struct guid *) req_msg.data, &heci_pthi_guid,
+		   sizeof(struct guid))) {
+
+		if (device->legacy_file_extension.state != HECI_FILE_CONNECTED) {
+			return_status = -ENODEV;
+			spin_unlock_bh(&device->device_lock);
+			goto end;
+		}
+		device->heci_host_clients[file_extension->host_client_id / 8] &=
+		    ~(1 << (file_extension->host_client_id % 8));
+                list_for_each_entry_safe(file_extension_pos, file_extension_next, &device->file_list, link) {
+			if ((file_extension->host_client_id ==
+			     file_extension_pos->host_client_id)
+			    && (file_extension->me_client_id ==
+				file_extension_pos->me_client_id)) {
+
+				DBG("remove file extension node host client = %d, ME client = %d\n",
+						file_extension_pos->host_client_id,
+						file_extension_pos->me_client_id);
+				list_del(&file_extension_pos->link);
+			}
+
+		}
+		DBG("free file extension memory\n");
+		kfree(file_extension);
+		file_extension = NULL;
+		file->private_data = &device->legacy_file_extension;
+		client = (struct heci_client *) res_msg.data;
+		client->max_message_length =
+		    device->me_clients[i].properteis.max_message_length;
+		client->protocol_version =
+		    device->me_clients[i].properteis.protocol_version;
+		return_status = device->legacy_file_extension.status;
+		spin_unlock_bh(&device->device_lock);
+
+		/* now copy the data to user space */
+		if (copy_to_user(k_msg.data, res_msg.data, res_msg.size)) {
+			return_status = -EFAULT;
+			goto end;
+		}
+		if (put_user(res_msg.size, &u_msg->size)) {
+			return_status = -EFAULT;
+			goto end;
+		}
+		goto end;
+	}
+	spin_lock(&file_extension->file_lock);
+	if (file_extension->state != HECI_FILE_CONNECTING) {
+		return_status = -ENODEV;
+		spin_unlock(&file_extension->file_lock);
+		spin_unlock_bh(&device->device_lock);
+		goto end;
+	}
+	spin_unlock(&file_extension->file_lock);
+	/* prepare the output buffer */
+	client = (struct heci_client *) res_msg.data;
+	client->max_message_length =
+	    device->me_clients[i].properteis.max_message_length;
+	client->protocol_version =
+	    device->me_clients[i].properteis.protocol_version;
+	if (device->host_buffer_is_empty
+	    && !other_client_is_connecting(device, file_extension)) {
+		device->host_buffer_is_empty = FALSE;
+		if (!heci_connect(device, file_extension)) {
+			return_status = -ENODEV;
+			spin_unlock_bh(&device->device_lock);
+			goto end;
+		} else {
+			file_extension->timer_count = CONNECT_TIMEOUT;
+			kernel_priv_cb->file_private = file_extension;
+			list_add_tail(&kernel_priv_cb->cb_list,
+				      &device->control_read_list.heci_cb.
+				      cb_list);
+		}
+
+
+	} else {
+		kernel_priv_cb->file_private = file_extension;
+		DBG("add connect cb to control write list\n");
+		list_add_tail(&kernel_priv_cb->cb_list,
+			      &device->control_write_list.heci_cb.cb_list);
+	}
+	spin_unlock_bh(&device->device_lock);
+	err =
+	    wait_event_timeout(device->wait_received_message,
+					     (HECI_FILE_CONNECTED == file_extension->state || HECI_FILE_DISCONNECTED == file_extension->state),
+					     timeout * HZ);
+	if (HECI_FILE_CONNECTED == file_extension->state) {
+		DBG("successfully to connect to FW client.\n");
+		return_status = file_extension->status;
+		/* now copy the data to user space */
+		if (copy_to_user(k_msg.data, res_msg.data, res_msg.size)) {
+			return_status = -EFAULT;
+			goto end;
+		}
+		if (put_user(res_msg.size, &u_msg->size)) {
+			return_status = -EFAULT;
+			goto end;
+		}
+		goto end;
+	} else {
+		DBG("failed to connect to FW client.file_extension->state = %d\n", file_extension->state);
+		if (!err)
+			DBG("wait_event_interruptible_timeout failed on client connect message fw response message\n");
+
+		return_status = -EFAULT;
+		goto remove_list;
+	}
+
+remove_list:
+	if (kernel_priv_cb) {
+		spin_lock_bh(&device->device_lock);
+		if (device->control_read_list.status == ESUCCESS
+				&& !list_empty(&device->control_read_list.heci_cb.cb_list)) {
+			list_for_each_entry_safe(kernel_priv_cb_pos, kernel_priv_cb_next, &device->control_read_list.heci_cb.cb_list, cb_list){
+				file_extension_list_temp =
+					(struct heci_file_private *)
+					kernel_priv_cb_pos->file_private;
+				if (file_extension_list_temp) {
+					if ((file_extension->host_client_id == file_extension_list_temp->host_client_id)
+							&& (file_extension->me_client_id == file_extension_list_temp->me_client_id))
+						list_del(&kernel_priv_cb_pos->cb_list);
+
+				}
+
+			}
+		}
+		if (device->control_write_list.status == ESUCCESS
+				&& !list_empty(&device->control_write_list.heci_cb.cb_list)) {
+			list_for_each_entry_safe(kernel_priv_cb_pos, kernel_priv_cb_next, &device->control_write_list.heci_cb.cb_list, cb_list){
+				file_extension_list_temp =
+					(struct heci_file_private *)
+					kernel_priv_cb_pos->file_private;
+				if (file_extension_list_temp) {
+					if ((file_extension->host_client_id == file_extension_list_temp->host_client_id)
+							&& (file_extension->me_client_id == file_extension_list_temp->me_client_id))
+						list_del(&kernel_priv_cb_pos->cb_list);
+
+				}
+
+			}
+		}
+		spin_unlock_bh(&device->device_lock);
+	}
+end:
+       DBG("free connect cb memory");
+	kfree(req_msg.data);
+	req_msg.data = NULL;
+	kfree(res_msg.data);
+	res_msg.data = NULL;
+	kfree(kernel_priv_cb);
+	kernel_priv_cb = NULL;
+	return return_status;
+}
+
+/**
+ * heci_ioctl_wd  - the wd IOCTL function
+ * @device_object -Device object for our driver
+ * @if_num  minor number
+ * @k_msg data in kernel on the stack
+ * @file_extension -extension of the file object
+ *
+ * @return :
+ *  0 on success,
+ *  negative on failure.
+ */
+int heci_ioctl_wd(struct iamt_heci_device * device, int if_num,
+		  struct heci_message_data k_msg,
+		  struct heci_file_private * file_extension)
+{
+	int return_status = ESUCCESS;
+	struct heci_message_data req_msg;	/*in kernel on the stack */
+	if (if_num != HECI_MINOR_NUMBER)
+		return -ENODEV;
+	spin_lock(&file_extension->file_lock);
+	if (k_msg.size != HECI_WATCHDOG_DATA_SIZE) {
+		DBG("User buffer has invalid size.\n");
+		spin_unlock(&file_extension->file_lock);
+		return -EMSGSIZE;
+	}
+	spin_unlock(&file_extension->file_lock);
+	req_msg.data = kmalloc(HECI_WATCHDOG_DATA_SIZE, GFP_KERNEL);
+	if (!req_msg.data) {
+		DBG("failed allocation request buffer size = %d.\n",
+		    HECI_WATCHDOG_DATA_SIZE);
+		return -ENOMEM;
+	}
+	req_msg.size = HECI_WATCHDOG_DATA_SIZE;
+
+	/* copy the message to kernel space - use a pointer already copied into kernel space */
+	if (copy_from_user(req_msg.data, k_msg.data, req_msg.size)) {
+		return_status = -EFAULT;
+		goto end;
+	}
+	spin_lock_bh(&device->device_lock);
+	if (device->heci_state != HECI_ENABLED) {
+		return_status = -ENODEV;
+		spin_unlock_bh(&device->device_lock);
+		goto end;
+	}
+
+	if (device->wd_file_extension.state != HECI_FILE_CONNECTED) {
+		return_status = -ENODEV;
+		spin_unlock_bh(&device->device_lock);
+		goto end;
+	}
+	if (!device->asf_mode) {
+		return_status = -EIO;
+		spin_unlock_bh(&device->device_lock);
+		goto end;
+	}
+
+	memcpy(&device->wd_data[HECI_WD_PARAMS_SIZE], req_msg.data,
+	       HECI_WATCHDOG_DATA_SIZE);
+
+	device->wd_timeout = (req_msg.data[1] << 8) +
+	    req_msg.data[0];
+	if (device->wd_timeout == 0) {
+		memcpy(device->wd_data, &stop_wd_params,
+		       HECI_WD_PARAMS_SIZE);
+		device->wd_pending = FALSE;
+		device->wd_due_counter = 1;	/* next timer */
+	} else {
+		memcpy(device->wd_data, &start_wd_params,
+		       HECI_WD_PARAMS_SIZE);
+		device->wd_pending = FALSE;
+		device->wd_due_counter = 1;
+	}
+	spin_unlock_bh(&device->device_lock);
+end:
+	kfree(req_msg.data);
+	req_msg.data = NULL;
+	return return_status;
+}
+
+
+/**
+ * heci_ioctl_bypass_wd  - the bypass_wd IOCTL function
+ * @device_object -Device object for our driver
+ * @if_num  minor number
+ * @k_msg data in kernel on the stack
+ * @file_extension -extension of the file object
+ * 
+ * @return :
+ *  0 on success,
+ *  negative on failure.
+ */
+int heci_ioctl_bypass_wd(struct iamt_heci_device * device, int if_num,
+		  struct heci_message_data k_msg,
+		  struct heci_file_private * file_extension)
+{
+	__u8 flag=0;
+	int return_status = ESUCCESS;
+
+	if (if_num != HECI_MINOR_NUMBER)
+		return -ENODEV;
+	spin_lock(&file_extension->file_lock);
+	if (k_msg.size < 1) {
+		DBG("user buffer less than HECI_WATCHDOG_DATA_SIZE .\n");
+		spin_unlock(&file_extension->file_lock);
+		return -EMSGSIZE;
+	}
+	spin_unlock(&file_extension->file_lock);
+	if (copy_from_user(&flag,k_msg.data,1)) {
+		return_status = -EFAULT;
+		goto end;
+	}
+
+	spin_lock_bh(&device->device_lock);
+	flag = flag ?(TRUE):(FALSE);
+	device->wd_bypass = flag;
+	spin_unlock_bh(&device->device_lock);
+end:
+	return return_status;
+}
+
+
+/**
+ * legacy_ioctl_send_message - send command data to pthi client
+ * @device_object -Device object for our driver
+ * @if_num  minor number
+ * @*u_msg pointer to user data struct in user space
+ * @k_msg data in kernel on the stack
+ * @file_extension -extension of the file object
+ *
+ * @return :
+ *  0 on success,
+ *  negative on failure.
+ */
+int legacy_ioctl_send_message(struct iamt_heci_device * device, int if_num,
+			      struct heci_message_data k_msg,
+			      struct file *file)
+{
+
+	int return_status = ESUCCESS;
+	struct heci_message_data req_msg, res_msg;	/*in kernel on the stack */
+	struct heci_cb_private *kernel_priv_cb = NULL;
+	struct heci_file_private *file_extension = file->private_data;
+	__u8 i;
+	req_msg.data = NULL;
+	res_msg.data = NULL;
+	if ((if_num != LEGACY_MINOR_NUMBER) || (!device))
+		return -ENODEV;
+	if (!file_extension)
+		return -ENODEV;
+	spin_lock_bh(&device->device_lock);
+	for (i = 0; i < device->num_heci_me_clients; i++) {
+		if (device->me_clients[i].client_id ==
+		    device->legacy_file_extension.me_client_id)
+			break;
+	}
+
+	BUG_ON(device->me_clients[i].client_id != file_extension->me_client_id);
+	if ((i == device->num_heci_me_clients)
+	    || (device->me_clients[i].client_id !=
+		device->legacy_file_extension.me_client_id)) {
+		spin_unlock_bh(&device->device_lock);
+		return -ENODEV;
+	} else if (k_msg.size >
+		   device->me_clients[i].properteis.max_message_length
+		   || k_msg.size <= 0) {
+		spin_unlock_bh(&device->device_lock);
+		return -EMSGSIZE;
+	}
+
+
+	spin_unlock_bh(&device->device_lock);
+	req_msg.data = kmalloc(k_msg.size, GFP_KERNEL);
+	res_msg.data = kmalloc(LEGACY_MTU, GFP_KERNEL);
+
+	if (!res_msg.data) {
+		DBG("failed allocation response buffer size = %d.\n",
+				(int) sizeof(struct heci_client));
+		if (req_msg.data) {
+
+			kfree(req_msg.data);
+			req_msg.data = NULL;
+			return -ENOMEM;
+		}
+	}
+	if (!req_msg.data) {
+		DBG("failed allocation request buffer size = %d.\n",
+				(int) sizeof(struct guid));
+		if (res_msg.data) {
+			kfree(res_msg.data);
+			res_msg.data = NULL;
+			return -ENOMEM;
+		}
+	}
+	req_msg.size = k_msg.size;
+	res_msg.size = LEGACY_MTU;
+	if (!k_msg.data) {
+		return_status = -EIO;
+		goto end;
+	}
+
+	/* copy the message to kernel space - use a pointer already copied into kernel space */
+	if (copy_from_user(req_msg.data, k_msg.data, k_msg.size)) {
+		return_status = -EFAULT;
+		goto end;
+	}
+	/* buffered ioctl cb */
+	kernel_priv_cb =
+	    kmalloc(sizeof(struct heci_cb_private), GFP_KERNEL);
+	if (!kernel_priv_cb) {
+		return_status = -ENOMEM;
+		goto end;
+	}
+	INIT_LIST_HEAD(&kernel_priv_cb->cb_list);
+
+	kernel_priv_cb->request_buffer.data = req_msg.data;
+	kernel_priv_cb->request_buffer.size = req_msg.size;
+	kernel_priv_cb->response_buffer.data = res_msg.data;
+	kernel_priv_cb->response_buffer.size = res_msg.size;
+	kernel_priv_cb->major_file_operations = HECI_IOCTL;
+	kernel_priv_cb->information = 0;
+	kernel_priv_cb->file_object = file;
+	kernel_priv_cb->file_private = file_extension;
+	spin_lock_bh(&device->device_lock);
+
+	if (device->heci_state != HECI_ENABLED) {
+		return_status = -ENODEV;
+		spin_unlock_bh(&device->device_lock);
+		goto end;
+	}
+	if (device->legacy_file_extension.state != HECI_FILE_CONNECTED) {
+		return_status = -ENODEV;
+		spin_unlock_bh(&device->device_lock);
+		goto end;
+	}
+
+
+	if (!list_empty(&device->pthi_cmd_list.heci_cb.cb_list)
+	    || device->legacy_state != HECI_LEGACY_IDLE) {
+		DBG("pthi_state = %d\n", (int) device->legacy_state);
+		DBG("add PTHI cb to pthi cmd waiting list");
+		list_add_tail(&kernel_priv_cb->cb_list,
+			      &device->pthi_cmd_list.heci_cb.cb_list);
+
+	} else {
+		DBG("call pthi write\n");
+		return_status = pthi_write(device, kernel_priv_cb);
+
+		if (ESUCCESS != return_status) {
+			DBG("pthi write failed with status = %d\n",
+			    return_status);
+			spin_unlock_bh(&device->device_lock);
+			goto end;
+		}
+	}
+	spin_unlock_bh(&device->device_lock);
+	return return_status;
+end:
+	kfree(req_msg.data);
+	req_msg.data = NULL;
+	kfree(res_msg.data);
+	res_msg.data = NULL;
+	kfree(kernel_priv_cb);
+	kernel_priv_cb = NULL;
+	return return_status;
+}
+
+
+/**
+ * legacy_ioctl_receive_message - receive  command data from pthi client
+ * @device_object -Device object for our driver
+ * @if_num  minor number
+ * @*u_msg pointer to user data struct in user space
+ * @k_msg data in kernel on the stack
+ * @file_extension -extension of the file object
+ *
+ * @return :
+ *  0 on success,
+ *  negative on failure.
+ */
+int legacy_ioctl_receive_message(struct iamt_heci_device * device, int if_num,
+				 struct heci_message_data *u_msg,
+				 struct heci_message_data k_msg,
+				 struct file *file)
+{
+
+	int return_status = ESUCCESS;
+	struct heci_message_data req_msg, res_msg;
+	struct heci_cb_private *kernel_priv_cb = NULL;
+	struct heci_file_private *file_extension = file->private_data;
+	__u8 i;
+	struct heci_file_private *file_extension_list_temp = NULL;
+	struct heci_cb_private *kernel_priv_cb_pos = NULL, *kernel_priv_cb_next = NULL;
+
+
+	res_msg.data = NULL;
+	req_msg.data = NULL;
+
+	if ((if_num != LEGACY_MINOR_NUMBER) || (!device))
+		return -ENODEV;
+	spin_lock_bh(&device->device_lock);
+	if (!file_extension) {
+		spin_unlock_bh(&device->device_lock);
+		return -ENODEV;
+	}
+	for (i = 0; i < device->num_heci_me_clients; i++)
+		if (device->me_clients[i].client_id ==
+		    device->legacy_file_extension.me_client_id)
+			break;
+
+	BUG_ON(device->me_clients[i].client_id !=
+	       file_extension->me_client_id);
+	if ((i == device->num_heci_me_clients)
+	    || (device->me_clients[i].client_id !=
+		device->legacy_file_extension.me_client_id)) {
+		spin_unlock_bh(&device->device_lock);
+		return -ENODEV;
+	}
+
+	if (device->pthi_read_complete_list.status == ESUCCESS) {
+		list_for_each_entry_safe(kernel_priv_cb_pos, kernel_priv_cb_next, &device->pthi_read_complete_list.heci_cb.cb_list, cb_list){
+			file_extension_list_temp =
+				(struct heci_file_private *)
+				kernel_priv_cb_pos->file_private;
+			if (file_extension_list_temp) {
+				if ((file_extension == &device->legacy_file_extension)
+						&& (kernel_priv_cb_pos->file_object == file)) {
+					list_del(&kernel_priv_cb_pos->cb_list);
+					kernel_priv_cb =
+						kernel_priv_cb_pos;
+					break;
+				}
+			}
+
+		}
+	}
+	if (!kernel_priv_cb) {
+		spin_unlock_bh(&device->device_lock);
+		return -EAGAIN;
+	}
+
+
+	res_msg.data = kernel_priv_cb->response_buffer.data;
+	res_msg.size = kernel_priv_cb->response_buffer.size;
+	req_msg.data = kernel_priv_cb->request_buffer.data;
+	req_msg.size = kernel_priv_cb->request_buffer.size;
+	DBG("pthi kernel_priv_cb->response_buffer size - %d\n",
+	    kernel_priv_cb->response_buffer.size);
+	DBG("pthi kernel_priv_cb->information - %lu\n",
+	    kernel_priv_cb->information);
+	spin_unlock_bh(&device->device_lock);
+
+	if (res_msg.size < kernel_priv_cb->information) {
+		return_status = -EMSGSIZE;
+		goto end;
+	}
+	/* now copy the data to user space */
+	if (copy_to_user(k_msg.data,
+				res_msg.data,
+				kernel_priv_cb->information)) {
+		return_status = -EFAULT;
+		goto end;
+	}
+	if (put_user(kernel_priv_cb->information, &u_msg->size)) {
+		return_status = -EFAULT;
+		goto end;
+	}
+end:
+	kfree(req_msg.data);
+	kfree(res_msg.data);
+	kfree(kernel_priv_cb);
+	return return_status;
+}
+
+/**
+ * find_pthi_read_list_entry - finds a PTHIlist entry for current file
+ * @device_object -Device object for our driver
+ *
+ * @return :
+ *  returned a list entry on success,
+ *  NULL on failure.
+ */
+struct heci_cb_private* find_pthi_read_list_entry(struct iamt_heci_device* device,
+					struct file* file, struct heci_file_private* file_extension)
+{
+	struct heci_file_private *file_extension_list_temp = NULL;
+	struct heci_cb_private *kernel_priv_cb_pos = NULL, *kernel_priv_cb_next = NULL;
+
+	if (device->pthi_read_complete_list.status == ESUCCESS
+	    && !list_empty(&device->pthi_read_complete_list.heci_cb.
+			   cb_list)) {
+               list_for_each_entry_safe(kernel_priv_cb_pos, kernel_priv_cb_next, &device->pthi_read_complete_list.heci_cb.cb_list, cb_list){
+			file_extension_list_temp =
+			    (struct heci_file_private *)
+			    kernel_priv_cb_pos->file_private;
+			if (file_extension_list_temp) {
+				if ((file_extension == &device->legacy_file_extension)
+				    && (kernel_priv_cb_pos->file_object == file)) {
+					return kernel_priv_cb_pos;
+				}
+			}
+		}
+	}
+	return NULL;
+}
+/**
+ * pthi_read - read data from pthi client
+ * @device_object -Device object for our driver
+ * @if_num  minor number
+ * @*u_msg pointer to user data in user space
+ * @length-user data length
+ *
+ * @return :
+ *  returned data length on success,
+ *  zero if no data to read,
+ *  negative on failure.
+ */
+int pthi_read(struct iamt_heci_device * device, int if_num, struct file *file,
+	      char *ubuf, size_t length, loff_t * offset)
+{
+
+	int return_status = ESUCCESS;
+	struct heci_cb_private *kernel_priv_cb = NULL;
+	struct heci_file_private *file_extension = file->private_data;
+	__u8 i;
+	unsigned long currtime = get_seconds();
+
+	if ((if_num != HECI_MINOR_NUMBER) || (!device))
+		return -ENODEV;
+
+	if (!file_extension)
+		return -ENODEV;
+
+	spin_lock_bh(&device->device_lock);
+	for (i = 0; i < device->num_heci_me_clients; i++)
+		if (device->me_clients[i].client_id ==
+		    device->legacy_file_extension.me_client_id)
+			break;
+	BUG_ON(device->me_clients[i].client_id != file_extension->me_client_id);
+	if ((i == device->num_heci_me_clients)
+	    || (device->me_clients[i].client_id !=
+		device->legacy_file_extension.me_client_id)) {
+		DBG("PTHI client not found\n");
+		spin_unlock_bh(&device->device_lock);
+		return -ENODEV;
+	}
+	kernel_priv_cb = find_pthi_read_list_entry(device, file, file_extension);
+	if (!kernel_priv_cb) {
+		spin_unlock_bh(&device->device_lock);
+		return 0; /* No more data to read */
+	}
+	else {
+		/* 15 sec for the message has expired */
+		if (kernel_priv_cb && currtime - kernel_priv_cb->read_time > LEGACY_READ_TIMER) {
+			list_del(&kernel_priv_cb->cb_list);
+			spin_unlock_bh(&device->device_lock);
+			return_status = -ETIMEDOUT;
+			goto free;
+		}
+		/* if the whole message will fit remove it from the list */
+		if ((kernel_priv_cb->information >= *offset)  &&
+				(length >= (kernel_priv_cb->information - *offset))) {
+			list_del(&kernel_priv_cb->cb_list);
+		}
+		/* end of the message has been reached */
+		else if ((kernel_priv_cb->information > 0) &&
+				(kernel_priv_cb->information <= *offset)) {
+			list_del(&kernel_priv_cb->cb_list);
+			return_status = 0;
+			spin_unlock_bh(&device->device_lock);
+			goto free;
+		}
+		/* else means that not full buffer will be read and do not remove message from deletion list */
+	}
+	DBG("pthi kernel_priv_cb->response_buffer size - %d\n",
+	    kernel_priv_cb->response_buffer.size);
+	DBG("pthi kernel_priv_cb->information - %lu\n",
+	    kernel_priv_cb->information);
+	spin_unlock_bh(&device->device_lock);
+
+	/* length is being turncated to PAGE_SIZE, however, the information may be longer */
+	length = length < (kernel_priv_cb->information - *offset) ?
+						length : (kernel_priv_cb->information - *offset);
+
+	if (copy_to_user
+	    (ubuf, kernel_priv_cb->response_buffer.data + *offset, length)) {
+		return_status = -EFAULT;
+	} else {
+		return_status = length;
+		if ((*offset + length) < kernel_priv_cb->information) {
+			*offset += length;
+			goto out;
+		}
+	}
+	DBG("free pthi cb memory\n");
+free:
+	*offset = 0;
+	kfree(kernel_priv_cb->request_buffer.data);
+	kfree(kernel_priv_cb->response_buffer.data);
+	kfree(kernel_priv_cb);
+out:
+	return return_status;
+}
+
+/**
+ * heci_start_read  - the start read client message function.
+ * @device_object -Device object for our driver
+ * @if_num  minor number
+ * @file_extension -extension of the file object
+ *
+ * @return :
+ *  0 on success,
+ *  negative on failure.
+ */
+int heci_start_read(struct iamt_heci_device * device, int if_num,
+		    struct heci_file_private * file_extension)
+{
+	int return_status = ESUCCESS;
+	__u8 i;
+	struct heci_cb_private *priv_cb = NULL;
+	if ((if_num != HECI_MINOR_NUMBER) || (!device)
+	    || (!file_extension)) {
+		DBG("receive wrong function input param\n.");
+		return -ENODEV;
+	}
+	if (file_extension->state != HECI_FILE_CONNECTED)
+		return -ENODEV;
+	spin_lock_bh(&device->device_lock);
+	if (device->heci_state != HECI_ENABLED) {
+		spin_unlock_bh(&device->device_lock);
+		return -ENODEV;
+	}
+	spin_unlock_bh(&device->device_lock);
+	DBG("check if read is pending\n");
+	if (file_extension->read_pending
+	    || file_extension->read_cb != NULL) {
+		DBG("read is pending");
+		return -EBUSY;
+	}
+	priv_cb = kmalloc(sizeof(struct heci_cb_private), GFP_KERNEL);
+	if (!priv_cb)
+		return -ENOMEM;
+
+	DBG("allocation call back success\n");
+	DBG("host client = %d, ME client = %d\n",
+	    file_extension->host_client_id, file_extension->me_client_id);
+	spin_lock_bh(&device->device_lock);
+	for (i = 0; i < device->num_heci_me_clients; i++)
+		if (device->me_clients[i].client_id ==
+		    file_extension->me_client_id)
+			break;
+
+	BUG_ON(device->me_clients[i].client_id !=
+	       file_extension->me_client_id);
+	if ((i == device->num_heci_me_clients)) {
+		return_status = -ENODEV;
+		goto unlock;
+	}
+
+	priv_cb->response_buffer.size =
+	    device->me_clients[i].properteis.max_message_length;
+	spin_unlock_bh(&device->device_lock);
+	priv_cb->response_buffer.data =
+	    kmalloc(priv_cb->response_buffer.size, GFP_KERNEL);
+	if (!priv_cb->response_buffer.data) {
+		return_status = -ENOMEM;
+		goto fail;
+	}
+	DBG("allocation call back data success\n");
+	priv_cb->major_file_operations = HECI_READ;
+	/* make sure information is zero before we start */
+	priv_cb->information = 0;
+	priv_cb->file_private = (void *) file_extension;
+	file_extension->read_cb = priv_cb;
+	spin_lock_bh(&device->device_lock);
+	if (device->host_buffer_is_empty) {
+		device->host_buffer_is_empty = FALSE;
+		if (!heci_send_flow_control(device, file_extension)) {
+			return_status = -ENODEV;
+			goto unlock;
+		} else {
+			list_add_tail(&priv_cb->cb_list,
+				      &device->read_list.heci_cb.cb_list);
+		}
+	} else {
+		list_add_tail(&priv_cb->cb_list,
+			      &device->control_write_list.heci_cb.cb_list);
+	}
+	spin_unlock_bh(&device->device_lock);
+	return return_status;
+unlock:
+	spin_unlock_bh(&device->device_lock);
+fail:
+	kfree(priv_cb->response_buffer.data);
+	priv_cb->response_buffer.data = NULL;
+	priv_cb->file_private = NULL;
+	kfree(priv_cb);
+	return return_status;
+}
+
+/**
+ * pthi_write - write legacy data to pthi client
+ * @device -Device object for our driver
+ * @kernel_priv_cb - heci call back struct
+ * @return :
+ *  0 on success,
+ *  negative on failure.
+ */
+int pthi_write(struct iamt_heci_device * device,
+	       struct heci_cb_private *kernel_priv_cb)
+{
+	int return_status = ESUCCESS;
+	struct heci_message_header heci_header;
+
+	if ((!device) || (!kernel_priv_cb))
+		return -ENODEV;
+
+	DBG("write data to pthi client\n");
+
+	device->legacy_state = HECI_LEGACY_WRITING;
+	device->legacy_current_cb = kernel_priv_cb;
+	device->legacy_file_object = kernel_priv_cb->file_object;
+	device->legacy_canceled = FALSE;
+	device->legacy_ioctl = TRUE;
+	device->legacy_message_buffer_size =
+	    kernel_priv_cb->request_buffer.size;
+	memcpy(device->legacy_message_buffer,
+	       kernel_priv_cb->request_buffer.data,
+	       kernel_priv_cb->request_buffer.size);
+	if (flow_control_credentials
+	    (device, &device->legacy_file_extension)
+	    && device->host_buffer_is_empty) {
+		device->host_buffer_is_empty = FALSE;
+		if (kernel_priv_cb->request_buffer.size >
+		    (((device->host_hw_state & H_CBD) >> 24) * sizeof(__u32)) - sizeof(struct heci_message_header)) {
+			heci_header.length =
+			    (((device->host_hw_state & H_CBD) >> 24) * sizeof(__u32)) - sizeof(struct heci_message_header);
+			heci_header.message_complete = 0;
+		} else {
+			heci_header.length =
+			    kernel_priv_cb->request_buffer.size;
+			heci_header.message_complete = 1;
+		}
+
+		heci_header.host_address =
+		    device->legacy_file_extension.host_client_id;
+		heci_header.me_address =
+		    device->legacy_file_extension.me_client_id;
+		heci_header.reserved = 0;
+		device->legacy_message_buffer_index += heci_header.length;
+		if (!heci_write_message(device, &heci_header,
+					       (unsigned char *) (device->legacy_message_buffer),
+					       heci_header.length))
+			return -ENODEV;
+
+		if (heci_header.message_complete) {
+
+			flow_control_reduce(device,
+					    &device->
+					    legacy_file_extension);
+			device->legacy_flow_control_pending = TRUE;
+			device->legacy_state = HECI_LEGACY_FLOW_CONTROL;
+			DBG("add pthi cb to write waiting list\n");
+			device->legacy_current_cb = kernel_priv_cb;
+			device->legacy_file_object = kernel_priv_cb->file_object;
+			list_add_tail(&kernel_priv_cb->cb_list,
+				      &device->write_waiting_list.heci_cb.
+				      cb_list);
+
+		} else {
+			DBG("message does not complete, so add pthi cb to write list\n");
+			list_add_tail(&kernel_priv_cb->cb_list,
+				      &device->write_list.heci_cb.cb_list);
+		}
+
+
+
+	} else {
+		if (TRUE != device->host_buffer_is_empty)
+			DBG("host buffer is not empty");
+		DBG("No flow control credentials, so add legacy cb to write list\n");
+		list_add_tail(&kernel_priv_cb->cb_list,
+			      &device->write_list.heci_cb.cb_list);
+	}
+	return return_status;
+}
+
+/**
+ * legacy_ioctl_send_message - send command data to pthi client
+ * @device -Device object for our driver
+ * @return :
+ *  0 on success,
+ *  negative on failure.
+ */
+void run_next_legacy_cmd(struct iamt_heci_device * device)
+{
+	struct heci_file_private *file_extension_temp = NULL;
+	struct heci_cb_private *kernel_priv_cb_pos = NULL, *kernel_priv_cb_next = NULL;
+	int legacy_write_status = ESUCCESS;
+
+	if (!device)
+		return;
+	device->legacy_message_buffer_size = 0;
+	device->legacy_message_buffer_index = 0;
+	device->legacy_canceled = FALSE;
+	device->legacy_ioctl = TRUE;
+	device->legacy_state = HECI_LEGACY_IDLE;
+	device->legacy_timer = 0;
+	device->legacy_file_object = NULL;
+
+	if (device->pthi_cmd_list.status == ESUCCESS
+	    && !list_empty(&device->pthi_cmd_list.heci_cb.cb_list)) {
+		DBG("complete pthi cmd_list CB\n ");
+               list_for_each_entry_safe(kernel_priv_cb_pos, kernel_priv_cb_next, &device->pthi_cmd_list.heci_cb.cb_list, cb_list){
+			list_del(&kernel_priv_cb_pos->cb_list);
+			file_extension_temp = (struct heci_file_private *) kernel_priv_cb_pos->file_private;
+
+			if ((file_extension_temp)
+			    && (file_extension_temp == &device->legacy_file_extension)) {
+				legacy_write_status =
+				    pthi_write(device, kernel_priv_cb_pos);
+				if (legacy_write_status != ESUCCESS) {
+					DBG("pthi write failed with status = %d\n",
+							legacy_write_status);
+					return;
+				}
+				break;
+			}
+		}
+	}
+	return;
+}
diff -Nurp linux-2.6.37/3rdparty/heci/kcompat.h linux-2.6.37.3rdparty/3rdparty/heci/kcompat.h
--- linux-2.6.37/3rdparty/heci/kcompat.h	1970-01-01 02:00:00.000000000 +0200
+++ linux-2.6.37.3rdparty/3rdparty/heci/kcompat.h	2008-01-24 14:04:22.000000000 +0200
@@ -0,0 +1,165 @@
+/*
+ * Part of Intel(R) Manageability Engine Interface Linux driver 
+ *
+ * Copyright (c) 2003 - 2007 Intel Corp.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions, and the following disclaimer,
+ *    without modification.
+ * 2. Redistributions in binary form must reproduce at minimum a disclaimer
+ *    substantially similar to the "NO WARRANTY" disclaimer below
+ *    ("Disclaimer") and any redistribution must be conditioned upon
+ *    including a substantially similar Disclaimer requirement for further
+ *    binary redistribution.
+ * 3. Neither the names of the above-listed copyright holders nor the names
+ *    of any contributors may be used to endorse or promote products derived
+ *    from this software without specific prior written permission.
+ *
+ * Alternatively, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") version 2 as published by the Free
+ * Software Foundation.
+ *
+ * NO WARRANTY
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGES.
+ *
+ */
+
+#ifndef _KCOMPAT_H_
+#define _KCOMPAT_H_
+
+#include <linux/version.h>
+#include <linux/init.h>
+#include <linux/types.h>
+#include <linux/errno.h>
+#include <linux/module.h>
+#include <linux/interrupt.h>
+#include <asm/io.h>
+
+
+/*****************************************************************************/
+#if ( LINUX_VERSION_CODE < KERNEL_VERSION(2,6,20) )
+#if ( LINUX_VERSION_CODE >= KERNEL_VERSION(2,5,28) )
+#undef INIT_WORK
+#define INIT_WORK(_work, _func) \
+do { \
+        INIT_LIST_HEAD(&(_work)->entry); \
+        (_work)->pending = 0; \
+        (_work)->func = (void (*)(void *))_func; \
+        (_work)->data = _work; \
+        init_timer(&(_work)->timer); \
+} while (0)
+#undef PREPARE_WORK
+#define PREPARE_WORK(_work, _func) \
+        do { \
+                (_work)->func =  (void (*)(void *))_func;\
+                (_work)->data = _work;\
+        } while (0)
+
+
+#endif
+
+#ifndef round_jiffies
+#define round_jiffies(x) x
+#endif
+
+#endif /* < 2.6.20 */
+
+
+/*****************************************************************************/
+#if ( LINUX_VERSION_CODE < KERNEL_VERSION(2,6,18) )
+
+#ifndef IRQF_PROBE_SHARED
+#ifdef SA_PROBEIRQ
+#define IRQF_PROBE_SHARED SA_PROBEIRQ
+#else
+#define IRQF_PROBE_SHARED 0
+#endif
+#endif
+
+#ifndef IRQF_SHARED
+#define IRQF_SHARED SA_SHIRQ
+#endif
+
+#ifndef ARRAY_SIZE
+#define ARRAY_SIZE(x) (sizeof(x) / sizeof((x)[0]))
+#endif
+
+#endif /* < 2.6.18 */
+
+
+/*****************************************************************************/
+#if ( LINUX_VERSION_CODE < KERNEL_VERSION(2,6,19) )
+
+#ifndef RHEL_VERSION
+#define RHEL_VERSION 0
+#endif
+#if (!(( RHEL_VERSION == 4 ) && ( RHEL_UPDATE >= 5 )))
+typedef irqreturn_t (*irq_handler_t)(int, void*, struct pt_regs *);
+#endif
+typedef irqreturn_t (*new_handler_t)(int, void*);
+static inline irqreturn_t _kc_request_irq(unsigned int irq, new_handler_t handler, unsigned long flags, const char *devname, void *dev_id)
+{
+        irq_handler_t new_handler = (irq_handler_t) handler;
+        return request_irq(irq, new_handler, flags, devname, dev_id);
+}
+
+#undef request_irq
+#define request_irq(irq, handler, flags, devname, dev_id) _kc_request_irq((irq), (handler), (flags), (devname), (dev_id))
+
+#endif
+
+
+/*****************************************************************************/
+#if ( LINUX_VERSION_CODE < KERNEL_VERSION(2,6,12) )
+#define SHUTDOWN_METHOD(method)
+#define HECI_REBOOT_NOTIFIER(reboot_notifier, driver, reboot_function) \
+static int heci_notify_reboot(struct notifier_block *nb, unsigned long event, void *p) \
+{ \
+	struct pci_dev *pdev = NULL; \
+\
+	switch(event){ \
+		case SYS_DOWN: \
+		case SYS_HALT: \
+		case SYS_POWER_OFF: \
+			while ((pdev = pci_find_device(PCI_ANY_ID, PCI_ANY_ID, pdev))) { \
+				if (pci_dev_driver(pdev) == &driver) { \
+					reboot_function(pdev); \
+				} \
+		} \
+	} \
+	return NOTIFY_DONE; \
+};\
+static struct notifier_block reboot_notifier = { \
+	.notifier_call = heci_notify_reboot, \
+	.next = NULL, \
+	.priority = 0 \
+};
+
+#define REGISTER_REBOOT_NOTIFIER(reboot_notifier) \
+	register_reboot_notifier(&reboot_notifier);
+#define UNREGISTER_REBOOT_NOTIFIER(reboot_notifier) \
+	unregister_reboot_notifier(&reboot_notifier);
+#else
+#define SHUTDOWN_METHOD(method) .shutdown = method,
+#define HECI_REBOOT_NOTIFIER(reboot_notifier, driver, reboot_function)
+#define REGISTER_REBOOT_NOTIFIER(reboot_notifier)
+#define UNREGISTER_REBOOT_NOTIFIER(reboot_notifier)
+#define heci_reboot_notifier
+#endif //( LINUX_VERSION_CODE < KERNEL_VERSION(2,6,12) )
+
+
+#endif
diff -Nurp linux-2.6.37/3rdparty/heci/Kconfig linux-2.6.37.3rdparty/3rdparty/heci/Kconfig
--- linux-2.6.37/3rdparty/heci/Kconfig	1970-01-01 02:00:00.000000000 +0200
+++ linux-2.6.37.3rdparty/3rdparty/heci/Kconfig	2008-02-19 20:34:22.000000000 +0200
@@ -0,0 +1,7 @@
+#
+# HECI device driver configuration
+#
+config HECI
+	tristate "HECI AMT driver"
+	---help---
+	If unsure, say N.
diff -Nurp linux-2.6.37/3rdparty/heci/Makefile linux-2.6.37.3rdparty/3rdparty/heci/Makefile
--- linux-2.6.37/3rdparty/heci/Makefile	1970-01-01 02:00:00.000000000 +0200
+++ linux-2.6.37.3rdparty/3rdparty/heci/Makefile	2008-02-19 20:03:44.000000000 +0200
@@ -0,0 +1,5 @@
+
+heci-objs := heci_init.o interrupt.o heci_interface.o io_heci.o \
+	     heci_main.o
+
+obj-$(CONFIG_HECI) += heci.o
diff -Nurp linux-2.6.37/3rdparty/heci/version.h linux-2.6.37.3rdparty/3rdparty/heci/version.h
--- linux-2.6.37/3rdparty/heci/version.h	1970-01-01 02:00:00.000000000 +0200
+++ linux-2.6.37.3rdparty/3rdparty/heci/version.h	2008-01-24 14:04:42.000000000 +0200
@@ -0,0 +1,53 @@
+/*
+ * Part of Intel(R) Manageability Engine Interface Linux driver
+ *
+ * Copyright (c) 2006-2007 Intel Corp.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions, and the following disclaimer,
+ *    without modification.
+ * 2. Redistributions in binary form must reproduce at minimum a disclaimer
+ *    substantially similar to the "NO WARRANTY" disclaimer below
+ *    ("Disclaimer") and any redistribution must be conditioned upon
+ *    including a substantially similar Disclaimer requirement for further
+ *    binary redistribution.
+ * 3. Neither the names of the above-listed copyright holders nor the names
+ *    of any contributors may be used to endorse or promote products derived
+ *    from this software without specific prior written permission.
+ *
+ * Alternatively, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") version 2 as published by the Free
+ * Software Foundation.
+ *
+ * NO WARRANTY
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGES.
+ *
+ */
+
+#ifndef HECI_VERSION_H
+#define HECI_VERSION_H
+
+#define MAJOR_VERSION              3
+#define MINOR_VERSION              2
+#define QUICK_FIX_NUMBER        0
+#define VER_BUILD               24
+
+#define str(s) name(s)
+#define name(s) #s
+#define DRIVER_VERSION		str(MAJOR_VERSION) "." str(MINOR_VERSION) "." str(QUICK_FIX_NUMBER) "." str(VER_BUILD)
+
+#endif
